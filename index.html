<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>134 Algorithms - –ü–æ–ª–Ω–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è –∑–∞–¥–∞—á C++</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/vs2015.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0d1117; color: #c9d1d9; }
        .container { max-width: 1600px; margin: 0 auto; padding: 20px; display: flex; gap: 20px; }
        
        /* Sidebar */
        .sidebar { width: 350px; background: #161b22; border-radius: 10px; padding: 20px; height: calc(100vh - 40px); position: sticky; top: 20px; border: 1px solid #30363d; }
        .sidebar h1 { color: #58a6ff; margin-bottom: 10px; font-size: 24px; }
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .stat { background: #0d1117; padding: 10px; border-radius: 6px; text-align: center; border: 1px solid #30363d; }
        .stat-number { font-size: 24px; font-weight: bold; color: #58a6ff; }
        .stat-label { font-size: 12px; color: #8b949e; }
        
        /* Search */
        .search { width: 100%; padding: 12px; background: #0d1117; border: 1px solid #30363d; border-radius: 6px; color: white; margin-bottom: 15px; }
        
        /* Categories */
        .categories { margin-bottom: 20px; }
        .category { background: #0d1117; padding: 8px 12px; margin-bottom: 5px; border-radius: 6px; border-left: 4px solid #58a6ff; font-size: 14px; }
        .category-count { float: right; background: #238636; padding: 2px 8px; border-radius: 10px; font-size: 12px; }
        
        /* Problem List */
        .problem-list { height: 500px; overflow-y: auto; }
        .problem-item { padding: 12px; margin-bottom: 8px; background: #0d1117; border-radius: 6px; border: 1px solid #30363d; cursor: pointer; transition: all 0.2s; }
        .problem-item:hover { background: #1c2128; border-color: #58a6ff; }
        .problem-item.active { background: #1c2128; border-color: #58a6ff; border-left: 4px solid #58a6ff; }
        .problem-id { color: #58a6ff; font-weight: bold; display: inline-block; width: 40px; }
        .problem-title { color: #c9d1d9; }
        .problem-meta { font-size: 12px; color: #8b949e; margin-top: 5px; }
        .difficulty { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; margin-left: 10px; }
        .easy { background: #238636; color: white; }
        .medium { background: #9e6a03; color: white; }
        .hard { background: #da3633; color: white; }
        
        /* Main Content */
        .main-content { flex: 1; background: #161b22; border-radius: 10px; padding: 30px; height: calc(100vh - 40px); overflow-y: auto; border: 1px solid #30363d; }
        .problem-header { margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid #30363d; }
        #problem-title { color: #f0f6fc; font-size: 28px; margin-bottom: 10px; }
        .header-meta { color: #8b949e; font-size: 14px; }
        .info-box { background: #0d1117; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #30363d; }
        .info-box h3 { color: #58a6ff; margin-bottom: 10px; }
        
        /* Code Section */
        .code-section { margin-top: 30px; }
        .code-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .btn { padding: 10px 20px; background: #238636; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; }
        .btn:hover { background: #2ea043; }
        .code-container { background: #0d1117; border-radius: 8px; overflow: hidden; border: 1px solid #30363d; }
        .code-toolbar { background: #161b22; padding: 15px; border-bottom: 1px solid #30363d; display: flex; justify-content: space-between; }
        pre { margin: 0; }
        code { font-family: 'Monaco', 'Consolas', monospace; font-size: 14px; }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0d1117; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #58a6ff; }
        
        /* Responsive */
        @media (max-width: 1200px) {
            .container { flex-direction: column; }
            .sidebar { width: 100%; height: auto; }
            .main-content { height: auto; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
            <h1>üßÆ 134 Algorithms</h1>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-number">134</div>
                    <div class="stat-label">–ó–∞–¥–∞—á</div>
                </div>
                <div class="stat">
                    <div class="stat-number">11</div>
                    <div class="stat-label">–ö–∞—Ç–µ–≥–æ—Ä–∏–π</div>
                </div>
            </div>
            
            <input type="text" class="search" id="search" placeholder="üîç –ü–æ–∏—Å–∫ –∑–∞–¥–∞—á–∏...">
            
            <div class="categories">
                <h3 style="color: #8b949e; margin-bottom: 10px; font-size: 14px;">–ö–ê–¢–ï–ì–û–†–ò–ò:</h3>
<div class="category">Arrays <span class="category-count">32</span></div>
<div class="category">Bit Manipulation <span class="category-count">4</span></div>
<div class="category">Design <span class="category-count">1</span></div>
<div class="category">Graphs <span class="category-count">5</span></div>
<div class="category">Heaps <span class="category-count">2</span></div>
<div class="category">Linked List <span class="category-count">12</span></div>
<div class="category">Maths <span class="category-count">1</span></div>
<div class="category">Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ) <span class="category-count">27</span></div>
<div class="category">Matrix <span class="category-count">6</span></div>
<div class="category">Strings <span class="category-count">6</span></div>
<div class="category">Trees <span class="category-count">38</span></div>
            </div>
            
            <div class="problem-list" id="problem-list">
                <!-- –°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á –±—É–¥–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω JavaScript -->
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <div class="problem-header">
                <h1 id="problem-title">–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É</h1>
                <div class="header-meta">
                    <span id="problem-id">#000</span> ‚Ä¢ 
                    <span id="problem-category">–ö–∞—Ç–µ–≥–æ—Ä–∏—è</span> ‚Ä¢ 
                    <span id="problem-difficulty" class="difficulty easy">–°–ª–æ–∂–Ω–æ—Å—Ç—å</span>
                </div>
            </div>
            
            <div class="info-box">
                <h3>üìù –û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏</h3>
                <p id="problem-description">–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É –∏–∑ —Å–ø–∏—Å–∫–∞ —Å–ª–µ–≤–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –æ–ø–∏—Å–∞–Ω–∏—è.</p>
            </div>
            
            <div class="info-box">
                <h3>üí° –ò–¥–µ—è —Ä–µ—à–µ–Ω–∏—è</h3>
                <p id="problem-idea">–ò–¥–µ—è —Ä–µ—à–µ–Ω–∏—è –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ –∑–∞–¥–∞—á–∏.</p>
            </div>
            
            <div class="code-section">
                <div class="code-header">
                    <h2 style="color: #c9d1d9;">üë®‚Äçüíª –†–µ—à–µ–Ω–∏–µ –Ω–∞ C++</h2>
                    <button id="copy-code" class="btn">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥</button>
                </div>
                
                <div class="code-container">
                    <div class="code-toolbar">
                        <div id="file-name" style="color: #8b949e; font-family: monospace;">solution.cpp</div>
                        <div style="color: #8b949e;">C++</div>
                    </div>
                    <pre><code id="code" class="language-cpp">// –í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∫–æ–¥–∞</code></pre>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/cpp.min.js"></script>
    
    <script>
        // –í–°–ï –ó–ê–î–ê–ß–ò –í–°–¢–†–û–ï–ù–´ –í –°–¢–†–ê–ù–ò–¶–£
        const problems = [
  {
    "id": 1,
    "title": "Linked List Cycle",
    "description": "–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ —Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ —Ü–∏–∫–ª.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º \"–ß–µ—Ä–µ–ø–∞—Ö–∞ –∏ –ó–∞—è—Ü\" - –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è, –æ–¥–∏–Ω –¥–≤–∏–∂–µ—Ç—Å—è –≤ 2 —Ä–∞–∑–∞ –±—ã—Å—Ç—Ä–µ–µ. –ï—Å–ª–∏ –µ—Å—Ç—å —Ü–∏–∫–ª, –æ–Ω–∏ –≤—Å—Ç—Ä–µ—Ç—è—Ç—Å—è.",
    "code": "class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if (!head) return false;\n        ListNode *slow = head, *fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) return true;\n        }\n        return false;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "001_linked_list_cycle.cpp"
  },
  {
    "id": 2,
    "title": "Reverse Linked List",
    "description": "–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –æ–¥–Ω–æ—Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫.",
    "idea": "–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ –º–µ–Ω—è–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è. –•—Ä–∞–Ω–∏–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π, —Ç–µ–∫—É—â–∏–π –∏ —Å–ª–µ–¥—É—é—â–∏–π —É–∑–ª—ã.",
    "code": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev = nullptr, *curr = head;\n        while (curr) {\n            ListNode *next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "002_reverse_linked_list.cpp"
  },
  {
    "id": 3,
    "title": "Delete Node in a Linked List",
    "description": "–£–¥–∞–ª–∏—Ç—å —É–∑–µ–ª (–Ω–µ —Ö–≤–æ—Å—Ç–æ–≤–æ–π) –∏–º–µ—è –¥–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ –∫ —ç—Ç–æ–º—É —É–∑–ª—É.",
    "idea": "–ö–æ–ø–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É–∑–ª–∞ –≤ —Ç–µ–∫—É—â–∏–π, –∑–∞—Ç–µ–º –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π —É–∑–µ–ª.",
    "code": "class Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node->val = node->next->val;\n        node->next = node->next->next;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "003_delete_node_in_a_linked_list.cpp"
  },
  {
    "id": 4,
    "title": "Merge Two Sorted Lists",
    "description": "–û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–≤—è–∑–Ω—ã—Ö —Å–ø–∏—Å–∫–∞ –≤ –æ–¥–∏–Ω –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π.",
    "idea": "–°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —É–∑–ª—ã –∏–∑ –æ–±–æ–∏—Ö —Å–ø–∏—Å–∫–æ–≤ –∏ —Å—Ç—Ä–æ–∏–º –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫, –≤—ã–±–∏—Ä–∞—è –º–µ–Ω—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ.",
    "code": "class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode dummy(0);\n        ListNode *tail = &dummy;\n        \n        while (l1 && l2) {\n            if (l1->val < l2->val) {\n                tail->next = l1;\n                l1 = l1->next;\n            } else {\n                tail->next = l2;\n                l2 = l2->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = l1 ? l1 : l2;\n        return dummy.next;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "004_merge_two_sorted_lists.cpp"
  },
  {
    "id": 5,
    "title": "Intersection of Two Linked Lists",
    "description": "–ù–∞–π—Ç–∏ —É–∑–µ–ª –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –¥–≤—É—Ö —Å–≤—è–∑–Ω—ã—Ö —Å–ø–∏—Å–∫–æ–≤.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –ø—Ä–æ—Ö–æ–¥—è—Ç –æ–±–∞ —Å–ø–∏—Å–∫–∞. –ö–æ–≥–¥–∞ –æ–¥–∏–Ω –¥–æ—Å—Ç–∏–≥–∞–µ—Ç –∫–æ–Ω—Ü–∞, –æ–Ω –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –∫ –Ω–∞—á–∞–ª—É –¥—Ä—É–≥–æ–≥–æ —Å–ø–∏—Å–∫–∞.",
    "code": "class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *a = headA, *b = headB;\n        while (a != b) {\n            a = a ? a->next : headB;\n            b = b ? b->next : headA;\n        }\n        return a;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "005_intersection_of_two_linked_lists.cpp"
  },
  {
    "id": 6,
    "title": "Linked List Cycle II",
    "description": "–ù–∞–π—Ç–∏ —É–∑–µ–ª, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ü–∏–∫–ª –≤ —Å–≤—è–∑–Ω–æ–º —Å–ø–∏—Å–∫–µ.",
    "idea": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ö–æ–¥–∏–º —Ç–æ—á–∫—É –≤—Å—Ç—Ä–µ—á–∏ –±—ã—Å—Ç—Ä–æ–≥–æ –∏ –º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π, –∑–∞—Ç–µ–º –ø–µ—Ä–µ–º–µ—â–∞–µ–º –æ–¥–∏–Ω —É–∫–∞–∑–∞—Ç–µ–ª—å –≤ –Ω–∞—á–∞–ª–æ –∏ –¥–≤–∏–≥–∞–µ–º –æ–±–∞ —Å –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π —Å–∫–æ—Ä–æ—Å—Ç—å—é.",
    "code": "class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (!head) return nullptr;\n        ListNode *slow = head, *fast = head;\n        \n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow->next;\n                    fast = fast->next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "006_linked_list_cycle_ii.cpp"
  },
  {
    "id": 7,
    "title": "Palindrome Linked List",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–º.",
    "idea": "–ù–∞—Ö–æ–¥–∏–º —Å–µ—Ä–µ–¥–∏–Ω—É —Å–ø–∏—Å–∫–∞, —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –≤—Ç–æ—Ä—É—é –ø–æ–ª–æ–≤–∏–Ω—É –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –ø–µ—Ä–≤–æ–π.",
    "code": "class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        if (!head || !head->next) return true;\n        \n        // –ù–∞—Ö–æ–¥–∏–º —Å–µ—Ä–µ–¥–∏–Ω—É\n        ListNode *slow = head, *fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        // –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –≤—Ç–æ—Ä—É—é –ø–æ–ª–æ–≤–∏–Ω—É\n        ListNode *prev = nullptr, *curr = slow;\n        while (curr) {\n            ListNode *next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        \n        // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –¥–≤–µ –ø–æ–ª–æ–≤–∏–Ω—ã\n        ListNode *left = head, *right = prev;\n        while (right) {\n            if (left->val != right->val) return false;\n            left = left->next;\n            right = right->next;\n        }\n        return true;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "007_palindrome_linked_list.cpp"
  },
  {
    "id": 8,
    "title": "Remove Linked List Elements",
    "description": "–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —É–∑–ª—ã —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º –∏–∑ —Å–≤—è–∑–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Ç–∏–≤–Ω—ã–π —É–∑–µ–ª –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–ª—É—á–∞—è, –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –≥–æ–ª–æ–≤—É —Å–ø–∏—Å–∫–∞.",
    "code": "class Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode *curr = &dummy;\n        \n        while (curr->next) {\n            if (curr->next->val == val) {\n                curr->next = curr->next->next;\n            } else {\n                curr = curr->next;\n            }\n        }\n        return dummy.next;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "008_remove_linked_list_elements.cpp"
  },
  {
    "id": 9,
    "title": "Remove Duplicates from Sorted List",
    "description": "–£–¥–∞–ª–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã –∏–∑ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Å–≤—è–∑–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞.",
    "idea": "–ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ —Å–ø–∏—Å–∫—É –∏ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —É–∑–ª—ã —Å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏.",
    "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode *curr = head;\n        while (curr && curr->next) {\n            if (curr->val == curr->next->val) {\n                curr->next = curr->next->next;\n            } else {\n                curr = curr->next;\n            }\n        }\n        return head;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "009_remove_duplicates_from_sorted_list.cpp"
  },
  {
    "id": 10,
    "title": "Remove Duplicates from Sorted List II",
    "description": "–£–¥–∞–ª–∏—Ç—å –≤—Å–µ —É–∑–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç –¥—É–±–ª–∏–∫–∞—Ç—ã, –æ—Å—Ç–∞–≤–∏–≤ —Ç–æ–ª—å–∫–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Ç–∏–≤–Ω—ã–π —É–∑–µ–ª –∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —É–∑–µ–ª –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –¥—É–±–ª–∏–∫–∞—Ç–æ–≤.",
    "code": "class Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode *prev = &dummy, *curr = head;\n        \n        while (curr) {\n            while (curr->next && curr->val == curr->next->val) {\n                curr = curr->next;\n            }\n            if (prev->next == curr) {\n                prev = prev->next;\n            } else {\n                prev->next = curr->next;\n            }\n            curr = curr->next;\n        }\n        return dummy.next;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "010_remove_duplicates_from_sorted_list_ii.cpp"
  },
  {
    "id": 11,
    "title": "Swap Nodes in Pairs",
    "description": "–ü–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏ –∫–∞–∂–¥—ã–µ –¥–≤–∞ —Å–æ—Å–µ–¥–Ω–∏—Ö —É–∑–ª–∞ –≤ —Å–≤—è–∑–Ω–æ–º —Å–ø–∏—Å–∫–µ.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Ç–∏–≤–Ω—ã–π —É–∑–µ–ª –∏ –º–µ–Ω—è–µ–º –ø–∞—Ä—ã —É–∑–ª–æ–≤, –æ–±–Ω–æ–≤–ª—è—è —É–∫–∞–∑–∞—Ç–µ–ª–∏.",
    "code": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode *curr = &dummy;\n        \n        while (curr->next && curr->next->next) {\n            ListNode *first = curr->next;\n            ListNode *second = curr->next->next;\n            \n            first->next = second->next;\n            second->next = first;\n            curr->next = second;\n            \n            curr = curr->next->next;\n        }\n        return dummy.next;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "011_swap_nodes_in_pairs.cpp"
  },
  {
    "id": 12,
    "title": "Remove Nth Node From End of List",
    "description": "–£–¥–∞–ª–∏—Ç—å n-–π —É–∑–µ–ª —Å –∫–æ–Ω—Ü–∞ —Å–≤—è–∑–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Å —Ä–∞–∑–Ω–∏—Ü–µ–π –≤ n —à–∞–≥–æ–≤. –ö–æ–≥–¥–∞ –ø–µ—Ä–≤—ã–π –¥–æ—Å—Ç–∏–≥–∞–µ—Ç –∫–æ–Ω—Ü–∞, –≤—Ç–æ—Ä–æ–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–µ—Ä–µ–¥ —É–∑–ª–æ–º –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.",
    "code": "class Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode *first = &dummy, *second = &dummy;\n        \n        for (int i = 0; i <= n; i++) {\n            first = first->next;\n        }\n        \n        while (first) {\n            first = first->next;\n            second = second->next;\n        }\n        \n        second->next = second->next->next;\n        return dummy.next;\n    }\n};",
    "category": "Linked List",
    "difficulty": "Easy",
    "filename": "012_remove_nth_node_from_end_of_list.cpp"
  },
  {
    "id": 13,
    "title": "Binary Tree Preorder Traversal",
    "description": "–í–µ—Ä–Ω—É—Ç—å preorder –æ–±—Ö–æ–¥ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–µ–∫ –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ —Ä–µ–∫—É—Ä—Å–∏–∏. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–æ—Ä–µ–Ω—å, –∑–∞—Ç–µ–º –ø—Ä–∞–≤–æ–≥–æ –∏ –ª–µ–≤–æ–≥–æ –ø–æ—Ç–æ–º–∫–æ–≤.",
    "code": "class Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> st;\n        if (root) st.push(root);\n        \n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            st.pop();\n            result.push_back(node->val);\n            \n            if (node->right) st.push(node->right);\n            if (node->left) st.push(node->left);\n        }\n        return result;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "013_binary_tree_preorder_traversal.cpp"
  },
  {
    "id": 14,
    "title": "BST Iterator",
    "description": "–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∏—Ç–µ—Ä–∞—Ç–æ—Ä –¥–ª—è –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –ø–æ–∏—Å–∫–∞.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–µ–∫ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–µ–≤—ã—Ö –ø–æ—Ç–æ–º–∫–æ–≤. –ü—Ä–∏ –≤—ã–∑–æ–≤–µ next() –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –Ω–∞–∏–º–µ–Ω—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç.",
    "code": "class BSTIterator {\n    stack<TreeNode*> st;\n    \n    void pushLeft(TreeNode* node) {\n        while (node) {\n            st.push(node);\n            node = node->left;\n        }\n    }\n    \npublic:\n    BSTIterator(TreeNode* root) {\n        pushLeft(root);\n    }\n    \n    int next() {\n        TreeNode* node = st.top();\n        st.pop();\n        pushLeft(node->right);\n        return node->val;\n    }\n    \n    bool hasNext() {\n        return !st.empty();\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "014_bst_iterator.cpp"
  },
  {
    "id": 15,
    "title": "Binary Tree Inorder Traversal",
    "description": "–í–µ—Ä–Ω—É—Ç—å inorder –æ–±—Ö–æ–¥ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.",
    "idea": "–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å—Ç–µ–∫–∞. –°–Ω–∞—á–∞–ª–∞ –∏–¥–µ–º –¥–æ —Å–∞–º–æ–≥–æ –ª–µ–≤–æ–≥–æ —É–∑–ª–∞.",
    "code": "class Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> st;\n        TreeNode* curr = root;\n        \n        while (curr || !st.empty()) {\n            while (curr) {\n                st.push(curr);\n                curr = curr->left;\n            }\n            curr = st.top();\n            st.pop();\n            result.push_back(curr->val);\n            curr = curr->right;\n        }\n        return result;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "015_binary_tree_inorder_traversal.cpp"
  },
  {
    "id": 16,
    "title": "Symmetric Tree",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω—ã–º.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ª–µ–≤–æ–µ –∏ –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤—å—è –∑–µ—Ä–∫–∞–ª—å–Ω–æ.",
    "code": "class Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (!root) return true;\n        return isMirror(root->left, root->right);\n    }\n    \n    bool isMirror(TreeNode* left, TreeNode* right) {\n        if (!left && !right) return true;\n        if (!left || !right) return false;\n        return (left->val == right->val) &&\n               isMirror(left->left, right->right) &&\n               isMirror(left->right, right->left);\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "016_symmetric_tree.cpp"
  },
  {
    "id": 17,
    "title": "Balanced Binary Tree",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã—Å–æ—Ç—ã –ø–æ–¥–¥–µ—Ä–µ–≤—å–µ–≤. –ï—Å–ª–∏ —Ä–∞–∑–Ω–∏—Ü–∞ –±–æ–ª—å—à–µ 1, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º -1.",
    "code": "class Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        return checkHeight(root) != -1;\n    }\n    \n    int checkHeight(TreeNode* node) {\n        if (!node) return 0;\n        \n        int left = checkHeight(node->left);\n        if (left == -1) return -1;\n        \n        int right = checkHeight(node->right);\n        if (right == -1) return -1;\n        \n        if (abs(left - right) > 1) return -1;\n        return max(left, right) + 1;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "017_balanced_binary_tree.cpp"
  },
  {
    "id": 18,
    "title": "Closest Binary Search Tree Value",
    "description": "–ù–∞–π—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ BST, –Ω–∞–∏–±–æ–ª–µ–µ –±–ª–∏–∑–∫–æ–µ –∫ —Ü–µ–ª–µ–≤–æ–º—É.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ BST –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏, –æ–±–Ω–æ–≤–ª—è—è –±–ª–∏–∂–∞–π—à–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ.",
    "code": "class Solution {\npublic:\n    int closestValue(TreeNode* root, double target) {\n        int closest = root->val;\n        while (root) {\n            if (abs(root->val - target) < abs(closest - target)) {\n                closest = root->val;\n            }\n            root = target < root->val ? root->left : root->right;\n        }\n        return closest;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "018_closest_binary_search_tree_value.cpp"
  },
  {
    "id": 19,
    "title": "Binary Tree Postorder Traversal",
    "description": "–í–µ—Ä–Ω—É—Ç—å postorder –æ–±—Ö–æ–¥ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.",
    "idea": "–ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π preorder –æ–±—Ö–æ–¥ (–∫–æ—Ä–µ–Ω—å-–ø—Ä–∞–≤–æ-–ª–µ–≤–æ) —Å –ø–æ—Å–ª–µ–¥—É—é—â–∏–º —Ä–∞–∑–≤–æ—Ä–æ—Ç–æ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.",
    "code": "class Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> st;\n        if (root) st.push(root);\n        \n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            st.pop();\n            result.push_back(node->val);\n            \n            if (node->left) st.push(node->left);\n            if (node->right) st.push(node->right);\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "019_binary_tree_postorder_traversal.cpp"
  },
  {
    "id": 20,
    "title": "Maximum Depth of Binary Tree",
    "description": "–ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≥–ª—É–±–∏–Ω—É –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –Ω–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≥–ª—É–±–∏–Ω—É –ª–µ–≤–æ–≥–æ –∏ –ø—Ä–∞–≤–æ–≥–æ –ø–æ–¥–¥–µ—Ä–µ–≤—å–µ–≤.",
    "code": "class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "020_maximum_depth_of_binary_tree.cpp"
  },
  {
    "id": 21,
    "title": "Invert Binary Tree",
    "description": "–ò–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏ –ª–µ–≤–æ–µ –∏ –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤—å—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞.",
    "code": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (!root) return nullptr;\n        \n        TreeNode* temp = root->left;\n        root->left = invertTree(root->right);\n        root->right = invertTree(temp);\n        \n        return root;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "021_invert_binary_tree.cpp"
  },
  {
    "id": 22,
    "title": "Same Tree",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∏–¥–µ–Ω—Ç–∏—á–Ω—ã –ª–∏ –¥–≤–∞ –±–∏–Ω–∞—Ä–Ω—ã—Ö –¥–µ—Ä–µ–≤–∞.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –∑–Ω–∞—á–µ–Ω–∏—è —É–∑–ª–æ–≤.",
    "code": "class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p && !q) return true;\n        if (!p || !q) return false;\n        return (p->val == q->val) &&\n               isSameTree(p->left, q->left) &&\n               isSameTree(p->right, q->right);\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "022_same_tree.cpp"
  },
  {
    "id": 23,
    "title": "Lowest Common Ancestor of BST",
    "description": "–ù–∞–π—Ç–∏ –Ω–∞–∏–º–µ–Ω—å—à–µ–≥–æ –æ–±—â–µ–≥–æ –ø—Ä–µ–¥–∫–∞ –¥–≤—É—Ö —É–∑–ª–æ–≤ –≤ BST.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ BST - LCA –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –º–µ–∂–¥—É –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –¥–≤—É—Ö —É–∑–ª–æ–≤.",
    "code": "class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        while (root) {\n            if (p->val < root->val && q->val < root->val) {\n                root = root->left;\n            } else if (p->val > root->val && q->val > root->val) {\n                root = root->right;\n            } else {\n                return root;\n            }\n        }\n        return nullptr;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "023_lowest_common_ancestor_of_bst.cpp"
  },
  {
    "id": 24,
    "title": "Lowest Common Ancestor of Binary Tree",
    "description": "–ù–∞–π—Ç–∏ –Ω–∞–∏–º–µ–Ω—å—à–µ–≥–æ –æ–±—â–µ–≥–æ –ø—Ä–µ–¥–∫–∞ –¥–≤—É—Ö —É–∑–ª–æ–≤ –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –¥–µ—Ä–µ–≤–µ.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫. –ï—Å–ª–∏ –æ–±–∞ —É–∑–ª–∞ –Ω–∞–π–¥–µ–Ω—ã –≤ —Ä–∞–∑–Ω—ã—Ö –ø–æ–¥–¥–µ—Ä–µ–≤—å—è—Ö, —Ç–µ–∫—É—â–∏–π —É–∑–µ–ª - LCA.",
    "code": "class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (!root || root == p || root == q) return root;\n        \n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n        \n        if (left && right) return root;\n        return left ? left : right;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "024_lowest_common_ancestor_of_binary_tree.cpp"
  },
  {
    "id": 25,
    "title": "Unique Binary Search Trees",
    "description": "–ü–æ—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö BST –¥–ª—è n —É–∑–ª–æ–≤.",
    "idea": "–ß–∏—Å–ª–∞ –ö–∞—Ç–∞–ª–∞–Ω–∞. –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ: dp[i] = Œ£(dp[j-1] * dp[i-j]).",
    "code": "class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = dp[1] = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] += dp[j - 1] * dp[i - j];\n            }\n        }\n        return dp[n];\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "025_unique_binary_search_trees.cpp"
  },
  {
    "id": 26,
    "title": "Unique Binary Search Trees II",
    "description": "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ BST –¥–ª—è n —É–∑–ª–æ–≤.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö BST –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ—Ä–Ω—è.",
    "code": "class Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        if (n == 0) return {};\n        return generate(1, n);\n    }\n    \n    vector<TreeNode*> generate(int start, int end) {\n        vector<TreeNode*> trees;\n        if (start > end) {\n            trees.push_back(nullptr);\n            return trees;\n        }\n        \n        for (int i = start; i <= end; i++) {\n            vector<TreeNode*> leftTrees = generate(start, i - 1);\n            vector<TreeNode*> rightTrees = generate(i + 1, end);\n            \n            for (TreeNode* left : leftTrees) {\n                for (TreeNode* right : rightTrees) {\n                    TreeNode* root = new TreeNode(i);\n                    root->left = left;\n                    root->right = right;\n                    trees.push_back(root);\n                }\n            }\n        }\n        return trees;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "026_unique_binary_search_trees_ii.cpp"
  },
  {
    "id": 27,
    "title": "Path Sum",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—É—Ç—å –æ—Ç –∫–æ—Ä–Ω—è –∫ –ª–∏—Å—Ç—É —Å –∑–∞–¥–∞–Ω–Ω–æ–π —Å—É–º–º–æ–π.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—É–º–º—É, –≤—ã—á–∏—Ç–∞—è –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ —É–∑–ª–∞.",
    "code": "class Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if (!root) return false;\n        if (!root->left && !root->right) return root->val == targetSum;\n        \n        int newSum = targetSum - root->val;\n        return hasPathSum(root->left, newSum) || hasPathSum(root->right, newSum);\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "027_path_sum.cpp"
  },
  {
    "id": 28,
    "title": "Binary Tree Maximum Path Sum",
    "description": "–ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É –ø—É—Ç–∏ –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –¥–µ—Ä–µ–≤–µ.",
    "idea": "–î–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞ –≤—ã—á–∏—Å–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É —á–µ—Ä–µ–∑ —ç—Ç–æ—Ç —É–∑–µ–ª –∏ –æ–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –º–∞–∫—Å–∏–º—É–º.",
    "code": "class Solution {\n    int maxSum;\npublic:\n    int maxPathSum(TreeNode* root) {\n        maxSum = INT_MIN;\n        maxGain(root);\n        return maxSum;\n    }\n    \n    int maxGain(TreeNode* node) {\n        if (!node) return 0;\n        \n        int leftGain = max(maxGain(node->left), 0);\n        int rightGain = max(maxGain(node->right), 0);\n        \n        int priceNewPath = node->val + leftGain + rightGain;\n        maxSum = max(maxSum, priceNewPath);\n        \n        return node->val + max(leftGain, rightGain);\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "028_binary_tree_maximum_path_sum.cpp"
  },
  {
    "id": 29,
    "title": "Binary Tree Level Order Traversal",
    "description": "–í–µ—Ä–Ω—É—Ç—å level order –æ–±—Ö–æ–¥ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.",
    "idea": "BFS —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –æ—á–µ—Ä–µ–¥–∏. –ù–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —É–∑–ª—ã.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        if (!root) return result;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            int size = q.size();\n            vector<int> level;\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                level.push_back(node->val);\n                \n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            result.push_back(level);\n        }\n        return result;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "029_binary_tree_level_order_traversal.cpp"
  },
  {
    "id": 30,
    "title": "Validate Binary Search Tree",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ BST.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å –ø–µ—Ä–µ–¥–∞—á–µ–π –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π.",
    "code": "class Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        return validate(root, LONG_MIN, LONG_MAX);\n    }\n    \n    bool validate(TreeNode* node, long minVal, long maxVal) {\n        if (!node) return true;\n        if (node->val <= minVal || node->val >= maxVal) return false;\n        \n        return validate(node->left, minVal, node->val) &&\n               validate(node->right, node->val, maxVal);\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "030_validate_binary_search_tree.cpp"
  },
  {
    "id": 31,
    "title": "Minimum Depth of Binary Tree",
    "description": "–ù–∞–π—Ç–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –≥–ª—É–±–∏–Ω—É –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –Ω–∞—Ö–æ–¥–∏–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –≥–ª—É–±–∏–Ω—É, —É—á–∏—Ç—ã–≤–∞—è —Å–ª—É—á–∞–π, –∫–æ–≥–¥–∞ –æ–¥–Ω–æ –∏–∑ –ø–æ–¥–¥–µ—Ä–µ–≤—å–µ–≤ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.",
    "code": "class Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (!root) return 0;\n        if (!root->left) return minDepth(root->right) + 1;\n        if (!root->right) return minDepth(root->left) + 1;\n        return min(minDepth(root->left), minDepth(root->right)) + 1;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "031_minimum_depth_of_binary_tree.cpp"
  },
  {
    "id": 32,
    "title": "Convert Sorted Array to Binary Search Tree",
    "description": "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ –≤ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ BST.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤—ã–±–∏—Ä–∞–µ–º —Å–µ—Ä–µ–¥–∏–Ω—É –º–∞—Å—Å–∏–≤–∞ –∫–∞–∫ –∫–æ—Ä–µ–Ω—å –∏ —Å—Ç—Ä–æ–∏–º –ª–µ–≤–æ–µ –∏ –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤—å—è.",
    "code": "class Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return buildBST(nums, 0, nums.size() - 1);\n    }\n    \n    TreeNode* buildBST(vector<int>& nums, int left, int right) {\n        if (left > right) return nullptr;\n        \n        int mid = left + (right - left) / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n        root->left = buildBST(nums, left, mid - 1);\n        root->right = buildBST(nums, mid + 1, right);\n        \n        return root;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "032_convert_sorted_array_to_binary_search_tree.cpp"
  },
  {
    "id": 33,
    "title": "Flatten Binary Tree to Linked List",
    "description": "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –≤ —Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ –Ω–∞ –º–µ—Å—Ç–µ.",
    "idea": "–ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π preorder –æ–±—Ö–æ–¥. –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞ –Ω–∞—Ö–æ–¥–∏–º —Å–∞–º—ã–π –ø—Ä–∞–≤—ã–π —É–∑–µ–ª –≤ –ª–µ–≤–æ–º –ø–æ–¥–¥–µ—Ä–µ–≤–µ.",
    "code": "class Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode* curr = root;\n        while (curr) {\n            if (curr->left) {\n                TreeNode* rightmost = curr->left;\n                while (rightmost->right) {\n                    rightmost = rightmost->right;\n                }\n                rightmost->right = curr->right;\n                curr->right = curr->left;\n                curr->left = nullptr;\n            }\n            curr = curr->right;\n        }\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "033_flatten_binary_tree_to_linked_list.cpp"
  },
  {
    "id": 34,
    "title": "Construct Binary Tree from Preorder and Inorder",
    "description": "–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –∏–∑ preorder –∏ inorder –æ–±—Ö–æ–¥–æ–≤.",
    "idea": "Preorder –¥–∞–µ—Ç –∫–æ—Ä–µ–Ω—å, inorder –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–¥–µ–ª–∏—Ç—å –ª–µ–≤–æ–µ –∏ –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤—å—è.",
    "code": "class Solution {\n    unordered_map<int, int> inorderMap;\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        for (int i = 0; i < inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);\n    }\n    \n    TreeNode* build(vector<int>& preorder, int preStart, int preEnd,\n                   vector<int>& inorder, int inStart, int inEnd) {\n        if (preStart > preEnd || inStart > inEnd) return nullptr;\n        \n        TreeNode* root = new TreeNode(preorder[preStart]);\n        int inRoot = inorderMap[root->val];\n        int numsLeft = inRoot - inStart;\n        \n        root->left = build(preorder, preStart + 1, preStart + numsLeft,\n                          inorder, inStart, inRoot - 1);\n        root->right = build(preorder, preStart + numsLeft + 1, preEnd,\n                           inorder, inRoot + 1, inEnd);\n        return root;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "034_construct_binary_tree_from_preorder_and_inorder.cpp"
  },
  {
    "id": 35,
    "title": "Binary Tree Paths",
    "description": "–í–µ—Ä–Ω—É—Ç—å –≤—Å–µ –ø—É—Ç–∏ –æ—Ç –∫–æ—Ä–Ω—è –∫ –ª–∏—Å—Ç—å—è–º –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –¥–µ—Ä–µ–≤–µ.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π DFS —Å –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø—É—Ç–∏.",
    "code": "class Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> result;\n        if (root) dfs(root, \"\", result);\n        return result;\n    }\n    \n    void dfs(TreeNode* node, string path, vector<string>& result) {\n        if (!node->left && !node->right) {\n            result.push_back(path + to_string(node->val));\n            return;\n        }\n        \n        if (node->left) dfs(node->left, path + to_string(node->val) + \"->\", result);\n        if (node->right) dfs(node->right, path + to_string(node->val) + \"->\", result);\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "035_binary_tree_paths.cpp"
  },
  {
    "id": 36,
    "title": "Recover Binary Search Tree",
    "description": "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å BST, –≤ –∫–æ—Ç–æ—Ä–æ–º –¥–≤–∞ —É–∑–ª–∞ –ø–æ–º–µ–Ω—è–Ω—ã –º–µ—Å—Ç–∞–º–∏.",
    "idea": "Inorder traversal –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –¥–≤—É—Ö –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω—ã—Ö —É–∑–ª–æ–≤.",
    "code": "class Solution {\n    TreeNode *first = nullptr, *second = nullptr, *prev = nullptr;\npublic:\n    void recoverTree(TreeNode* root) {\n        inorder(root);\n        swap(first->val, second->val);\n    }\n    \n    void inorder(TreeNode* node) {\n        if (!node) return;\n        \n        inorder(node->left);\n        \n        if (prev && prev->val > node->val) {\n            if (!first) first = prev;\n            second = node;\n        }\n        prev = node;\n        \n        inorder(node->right);\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "036_recover_binary_search_tree.cpp"
  },
  {
    "id": 37,
    "title": "Path Sum II",
    "description": "–ù–∞–π—Ç–∏ –≤—Å–µ –ø—É—Ç–∏ –æ—Ç –∫–æ—Ä–Ω—è –∫ –ª–∏—Å—Ç—É —Å –∑–∞–¥–∞–Ω–Ω–æ–π —Å—É–º–º–æ–π.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π DFS —Å backtracking –¥–ª—è –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è –ø—É—Ç–µ–π.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        vector<vector<int>> result;\n        vector<int> path;\n        dfs(root, targetSum, path, result);\n        return result;\n    }\n    \n    void dfs(TreeNode* node, int sum, vector<int>& path, vector<vector<int>>& result) {\n        if (!node) return;\n        \n        path.push_back(node->val);\n        sum -= node->val;\n        \n        if (!node->left && !node->right && sum == 0) {\n            result.push_back(path);\n        }\n        \n        dfs(node->left, sum, path, result);\n        dfs(node->right, sum, path, result);\n        \n        path.pop_back();\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "037_path_sum_ii.cpp"
  },
  {
    "id": 38,
    "title": "Binary Tree Level Order Traversal II",
    "description": "–í–µ—Ä–Ω—É—Ç—å level order –æ–±—Ö–æ–¥ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö.",
    "idea": "BFS –∫–∞–∫ –æ–±—ã—á–Ω–æ, –∑–∞—Ç–µ–º —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> result;\n        if (!root) return result;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            int size = q.size();\n            vector<int> level;\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                level.push_back(node->val);\n                \n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            result.push_back(level);\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "038_binary_tree_level_order_traversal_ii.cpp"
  },
  {
    "id": 39,
    "title": "Kth Smallest Element in BST",
    "description": "–ù–∞–π—Ç–∏ k-–π –Ω–∞–∏–º–µ–Ω—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ BST.",
    "idea": "Inorder traversal –¥–æ k-–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.",
    "code": "class Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode*> st;\n        TreeNode* curr = root;\n        \n        while (curr || !st.empty()) {\n            while (curr) {\n                st.push(curr);\n                curr = curr->left;\n            }\n            curr = st.top();\n            st.pop();\n            if (--k == 0) return curr->val;\n            curr = curr->right;\n        }\n        return -1;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "039_kth_smallest_element_in_bst.cpp"
  },
  {
    "id": 40,
    "title": "Construct Binary Tree from Inorder and Postorder",
    "description": "–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –∏–∑ inorder –∏ postorder –æ–±—Ö–æ–¥–æ–≤.",
    "idea": "Postorder –¥–∞–µ—Ç –∫–æ—Ä–µ–Ω—å —Å –∫–æ–Ω—Ü–∞, inorder –ø–æ–∑–≤–æ–ª—è–µ—Ç —Ä–∞–∑–¥–µ–ª–∏—Ç—å –ø–æ–¥–¥–µ—Ä–µ–≤—å—è.",
    "code": "class Solution {\n    unordered_map<int, int> inorderMap;\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        for (int i = 0; i < inorder.size(); i++) {\n            inorderMap[inorder[i]] = i;\n        }\n        return build(inorder, 0, inorder.size() - 1,\n                    postorder, 0, postorder.size() - 1);\n    }\n    \n    TreeNode* build(vector<int>& inorder, int inStart, int inEnd,\n                   vector<int>& postorder, int postStart, int postEnd) {\n        if (inStart > inEnd || postStart > postEnd) return nullptr;\n        \n        TreeNode* root = new TreeNode(postorder[postEnd]);\n        int inRoot = inorderMap[root->val];\n        int numsLeft = inRoot - inStart;\n        \n        root->left = build(inorder, inStart, inRoot - 1,\n                          postorder, postStart, postStart + numsLeft - 1);\n        root->right = build(inorder, inRoot + 1, inEnd,\n                           postorder, postStart + numsLeft, postEnd - 1);\n        return root;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "040_construct_binary_tree_from_inorder_and_postorder.cpp"
  },
  {
    "id": 41,
    "title": "Binary Tree Right Side View",
    "description": "–í–µ—Ä–Ω—É—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è —É–∑–ª–æ–≤, –≤–∏–¥–∏–º—ã—Ö —Å –ø—Ä–∞–≤–æ–π —Å—Ç–æ—Ä–æ–Ω—ã –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.",
    "idea": "BFS, –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è.",
    "code": "class Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> result;\n        if (!root) return result;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                \n                if (i == size - 1) result.push_back(node->val);\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n        }\n        return result;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "041_binary_tree_right_side_view.cpp"
  },
  {
    "id": 42,
    "title": "Sum Root to Leaf Numbers",
    "description": "–ù–∞–π—Ç–∏ —Å—É–º–º—É –≤—Å–µ—Ö —á–∏—Å–µ–ª, –æ–±—Ä–∞–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø—É—Ç—è–º–∏ –æ—Ç –∫–æ—Ä–Ω—è –∫ –ª–∏—Å—Ç—å—è–º.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏–µ —á–∏—Å–ª–∞ –ø—Ä–∏ –æ–±—Ö–æ–¥–µ –¥–µ—Ä–µ–≤–∞.",
    "code": "class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\n    \n    int dfs(TreeNode* node, int currentSum) {\n        if (!node) return 0;\n        \n        currentSum = currentSum * 10 + node->val;\n        if (!node->left && !node->right) return currentSum;\n        \n        return dfs(node->left, currentSum) + dfs(node->right, currentSum);\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "042_sum_root_to_leaf_numbers.cpp"
  },
  {
    "id": 43,
    "title": "Binary Tree Zigzag Level Order Traversal",
    "description": "–í–µ—Ä–Ω—É—Ç—å zigzag level order –æ–±—Ö–æ–¥ (—Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ, –∑–∞—Ç–µ–º —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ).",
    "idea": "BFS —Å —á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        if (!root) return result;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        bool leftToRight = true;\n        \n        while (!q.empty()) {\n            int size = q.size();\n            vector<int> level(size);\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                \n                int index = leftToRight ? i : size - 1 - i;\n                level[index] = node->val;\n                \n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            result.push_back(level);\n            leftToRight = !leftToRight;\n        }\n        return result;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "043_binary_tree_zigzag_level_order_traversal.cpp"
  },
  {
    "id": 44,
    "title": "House Robber III",
    "description": "–ú–∞–∫—Å–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å—É–º–º—É –æ–≥—Ä–∞–±–ª–µ–Ω–∏—è –¥–æ–º–æ–≤, —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤ –≤–∏–¥–µ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.",
    "idea": "–î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –¥–µ—Ä–µ–≤–µ. –î–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞ —Å—á–∏—Ç–∞–µ–º –¥–≤–∞ —Å–ª—É—á–∞—è: –≥—Ä–∞–±–∏–º –∏–ª–∏ –Ω–µ –≥—Ä–∞–±–∏–º.",
    "code": "class Solution {\npublic:\n    int rob(TreeNode* root) {\n        auto result = dfs(root);\n        return max(result.first, result.second);\n    }\n    \n    pair<int, int> dfs(TreeNode* node) {\n        if (!node) return {0, 0};\n        \n        auto left = dfs(node->left);\n        auto right = dfs(node->right);\n        \n        int rob = node->val + left.second + right.second;\n        int notRob = max(left.first, left.second) + max(right.first, right.second);\n        \n        return {rob, notRob};\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "044_house_robber_iii.cpp"
  },
  {
    "id": 45,
    "title": "Inorder Successor in BST",
    "description": "–ù–∞–π—Ç–∏ inorder –ø—Ä–µ–µ–º–Ω–∏–∫–∞ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —É–∑–ª–∞ –≤ BST.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–æ–π—Å—Ç–≤–∞ BST –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –∫ –ø—Ä–µ–µ–º–Ω–∏–∫—É.",
    "code": "class Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        TreeNode* successor = nullptr;\n        \n        while (root) {\n            if (p->val < root->val) {\n                successor = root;\n                root = root->left;\n            } else {\n                root = root->right;\n            }\n        }\n        return successor;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "045_inorder_successor_in_bst.cpp"
  },
  {
    "id": 46,
    "title": "Binary Tree Longest Consecutive Sequence",
    "description": "–ù–∞–π—Ç–∏ –¥–ª–∏–Ω—É —Å–∞–º–æ–π –¥–ª–∏–Ω–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤ –±–∏–Ω–∞—Ä–Ω–æ–º –¥–µ—Ä–µ–≤–µ.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ —Å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º —Ç–µ–∫—É—â–µ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.",
    "code": "class Solution {\npublic:\n    int longestConsecutive(TreeNode* root) {\n        return dfs(root, nullptr, 0);\n    }\n    \n    int dfs(TreeNode* node, TreeNode* parent, int length) {\n        if (!node) return length;\n        \n        length = (parent && node->val == parent->val + 1) ? length + 1 : 1;\n        return max(length, max(dfs(node->left, node, length),\n                              dfs(node->right, node, length)));\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "046_binary_tree_longest_consecutive_sequence.cpp"
  },
  {
    "id": 47,
    "title": "Verify Preorder Sequence in BST",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –º–∞—Å—Å–∏–≤ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º preorder –æ–±—Ö–æ–¥–æ–º BST.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–µ–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ BST —Å–≤–æ–π—Å—Ç–≤ –ø—Ä–∏ preorder –æ–±—Ö–æ–¥–µ.",
    "code": "class Solution {\npublic:\n    bool verifyPreorder(vector<int>& preorder) {\n        stack<int> st;\n        int lowerBound = INT_MIN;\n        \n        for (int val : preorder) {\n            if (val < lowerBound) return false;\n            \n            while (!st.empty() && val > st.top()) {\n                lowerBound = st.top();\n                st.pop();\n            }\n            st.push(val);\n        }\n        return true;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "047_verify_preorder_sequence_in_bst.cpp"
  },
  {
    "id": 48,
    "title": "Binary Tree Upside Down",
    "description": "–ü–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –≤–≤–µ—Ä—Ö –Ω–æ–≥–∞–º–∏.",
    "idea": "–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞–∑–≤–æ—Ä–æ—Ç–∞ –¥–µ—Ä–µ–≤–∞.",
    "code": "class Solution {\npublic:\n    TreeNode* upsideDownBinaryTree(TreeNode* root) {\n        TreeNode *curr = root, *prev = nullptr, *next = nullptr, *temp = nullptr;\n        \n        while (curr) {\n            next = curr->left;\n            curr->left = temp;\n            temp = curr->right;\n            curr->right = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "048_binary_tree_upside_down.cpp"
  },
  {
    "id": 49,
    "title": "Count Univalue Subtrees",
    "description": "–ü–æ—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏–≤–∞–ª—å–Ω—ã—Ö –ø–æ–¥–¥–µ—Ä–µ–≤—å–µ–≤ (–≤—Å–µ —É–∑–ª—ã –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ).",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–≤–∞–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–¥–¥–µ—Ä–µ–≤–∞.",
    "code": "class Solution {\npublic:\n    int countUnivalSubtrees(TreeNode* root) {\n        int count = 0;\n        isUnival(root, count);\n        return count;\n    }\n    \n    bool isUnival(TreeNode* node, int& count) {\n        if (!node) return true;\n        \n        bool left = isUnival(node->left, count);\n        bool right = isUnival(node->right, count);\n        \n        if (left && right) {\n            if (node->left && node->left->val != node->val) return false;\n            if (node->right && node->right->val != node->val) return false;\n            count++;\n            return true;\n        }\n        return false;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "049_count_univalue_subtrees.cpp"
  },
  {
    "id": 50,
    "title": "Serialize and Deserialize Binary Tree",
    "description": "–°–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞—Ç—å –∏ –¥–µ—Å–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞—Ç—å –±–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ.",
    "idea": "Preorder –æ–±—Ö–æ–¥ —Å –º–∞—Ä–∫–µ—Ä–∞–º–∏ –¥–ª—è null —É–∑–ª–æ–≤.",
    "code": "class Codec {\npublic:\n    string serialize(TreeNode* root) {\n        if (!root) return \"#\";\n        return to_string(root->val) + \",\" + serialize(root->left) + \",\" + serialize(root->right);\n    }\n\n    TreeNode* deserialize(string data) {\n        stringstream ss(data);\n        return deserializeHelper(ss);\n    }\n    \n    TreeNode* deserializeHelper(stringstream& ss) {\n        string val;\n        getline(ss, val, ',');\n        if (val == \"#\") return nullptr;\n        \n        TreeNode* root = new TreeNode(stoi(val));\n        root->left = deserializeHelper(ss);\n        root->right = deserializeHelper(ss);\n        return root;\n    }\n};",
    "category": "Trees",
    "difficulty": "Medium",
    "filename": "050_serialize_and_deserialize_binary_tree.cpp"
  },
  {
    "id": 51,
    "title": "Number of Connected Components in Undirected Graph",
    "description": "–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤—è–∑–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –≤ –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º Union-Find –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç.",
    "code": "class Solution {\npublic:\n    int countComponents(int n, vector<vector<int>>& edges) {\n        vector<int> parent(n);\n        for (int i = 0; i < n; i++) parent[i] = i;\n        \n        int components = n;\n        for (auto& edge : edges) {\n            int root1 = find(parent, edge[0]);\n            int root2 = find(parent, edge[1]);\n            if (root1 != root2) {\n                parent[root1] = root2;\n                components--;\n            }\n        }\n        return components;\n    }\n    \n    int find(vector<int>& parent, int x) {\n        while (parent[x] != x) {\n            parent[x] = parent[parent[x]];\n            x = parent[x];\n        }\n        return x;\n    }\n};",
    "category": "Graphs",
    "difficulty": "Medium",
    "filename": "051_number_of_connected_components_in_undirected_graph.cpp"
  },
  {
    "id": 52,
    "title": "Course Schedule",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –∑–∞–≤–µ—Ä—à–∏—Ç—å –≤—Å–µ –∫—É—Ä—Å—ã —Å —É—á–µ—Ç–æ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π.",
    "idea": "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ü–∏–∫–ª–∏—á–Ω–æ—Å—Ç–∏ –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞ —Å –ø–æ–º–æ—â—å—é —Ç–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏.",
    "code": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numCourses);\n        vector<int> indegree(numCourses, 0);\n        \n        for (auto& pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n        \n        queue<int> q;\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) q.push(i);\n        }\n        \n        int count = 0;\n        while (!q.empty()) {\n            int course = q.front();\n            q.pop();\n            count++;\n            \n            for (int neighbor : graph[course]) {\n                if (--indegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n        return count == numCourses;\n    }\n};",
    "category": "Graphs",
    "difficulty": "Medium",
    "filename": "052_course_schedule.cpp"
  },
  {
    "id": 53,
    "title": "Graph Valid Tree",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –æ–±—Ä–∞–∑—É—é—Ç –ª–∏ —Ä–µ–±—Ä–∞ –≤–∞–ª–∏–¥–Ω–æ–µ –¥–µ—Ä–µ–≤–æ.",
    "idea": "–î–µ—Ä–µ–≤–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å–≤—è–∑–Ω—ã–º –∏ –Ω–µ –∏–º–µ—Ç—å —Ü–∏–∫–ª–æ–≤, —Å n-1 —Ä–µ–±—Ä–∞–º–∏.",
    "code": "class Solution {\npublic:\n    bool validTree(int n, vector<vector<int>>& edges) {\n        if (edges.size() != n - 1) return false;\n        \n        vector<vector<int>> graph(n);\n        for (auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        vector<bool> visited(n, false);\n        if (hasCycle(graph, visited, 0, -1)) return false;\n        \n        for (bool v : visited) {\n            if (!v) return false;\n        }\n        return true;\n    }\n    \n    bool hasCycle(vector<vector<int>>& graph, vector<bool>& visited, int node, int parent) {\n        visited[node] = true;\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                if (hasCycle(graph, visited, neighbor, node)) return true;\n            } else if (neighbor != parent) {\n                return true;\n            }\n        }\n        return false;\n    }\n};",
    "category": "Graphs",
    "difficulty": "Medium",
    "filename": "053_graph_valid_tree.cpp"
  },
  {
    "id": 54,
    "title": "Course Schedule II",
    "description": "–ù–∞–π—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è –∫—É—Ä—Å–æ–≤ —Å —É—á–µ—Ç–æ–º –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π.",
    "idea": "–¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º –ø–æ—Ä—è–¥–∫–∞.",
    "code": "class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numCourses);\n        vector<int> indegree(numCourses, 0);\n        \n        for (auto& pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n        \n        queue<int> q;\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) q.push(i);\n        }\n        \n        vector<int> result;\n        while (!q.empty()) {\n            int course = q.front();\n            q.pop();\n            result.push_back(course);\n            \n            for (int neighbor : graph[course]) {\n                if (--indegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        if (result.size() != numCourses) return {};\n        return result;\n    }\n};",
    "category": "Graphs",
    "difficulty": "Medium",
    "filename": "054_course_schedule_ii.cpp"
  },
  {
    "id": 55,
    "title": "Number of Islands",
    "description": "–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Å—Ç—Ä–æ–≤–æ–≤ –≤ –¥–≤—É–º–µ—Ä–Ω–æ–π —Å–µ—Ç–∫–µ.",
    "idea": "DFS –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–≤—è–∑–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –∏–∑ '1'.",
    "code": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if (grid.empty()) return 0;\n        \n        int count = 0;\n        int m = grid.size(), n = grid[0].size();\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j, m, n);\n                }\n            }\n        }\n        return count;\n    }\n    \n    void dfs(vector<vector<char>>& grid, int i, int j, int m, int n) {\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') return;\n        \n        grid[i][j] = '0'; // –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –ø–æ—Å–µ—â–µ–Ω–Ω—ã–π\n        \n        dfs(grid, i + 1, j, m, n);\n        dfs(grid, i - 1, j, m, n);\n        dfs(grid, i, j + 1, m, n);\n        dfs(grid, i, j - 1, m, n);\n    }\n};",
    "category": "Graphs",
    "difficulty": "Medium",
    "filename": "055_number_of_islands.cpp"
  },
  {
    "id": 56,
    "title": "Merge K Sorted Lists",
    "description": "–û–±—ä–µ–¥–∏–Ω–∏—Ç—å k –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–≤—è–∑–Ω—ã—Ö —Å–ø–∏—Å–∫–æ–≤ –≤ –æ–¥–∏–Ω –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∫—É—á—É (min-heap) –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ –Ω–∞–∏–º–µ–Ω—å—à–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.",
    "code": "class Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);\n        \n        for (ListNode* list : lists) {\n            if (list) pq.push(list);\n        }\n        \n        ListNode dummy(0);\n        ListNode* tail = &dummy;\n        \n        while (!pq.empty()) {\n            ListNode* node = pq.top();\n            pq.pop();\n            tail->next = node;\n            tail = tail->next;\n            \n            if (node->next) pq.push(node->next);\n        }\n        return dummy.next;\n    }\n};",
    "category": "Heaps",
    "difficulty": "Medium",
    "filename": "056_merge_k_sorted_lists.cpp"
  },
  {
    "id": 57,
    "title": "Kth Largest Element in an Array",
    "description": "–ù–∞–π—Ç–∏ k-–π –Ω–∞–∏–±–æ–ª—å—à–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ –º–∞—Å—Å–∏–≤–µ.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∫—É—á—É —Ä–∞–∑–º–µ—Ä–∞ k –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è k –Ω–∞–∏–±–æ–ª—å—à–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
    "code": "class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        priority_queue<int, vector<int>, greater<int>> pq;\n        \n        for (int num : nums) {\n            pq.push(num);\n            if (pq.size() > k) {\n                pq.pop();\n            }\n        }\n        return pq.top();\n    }\n};",
    "category": "Heaps",
    "difficulty": "Medium",
    "filename": "057_kth_largest_element_in_an_array.cpp"
  },
  {
    "id": 58,
    "title": "Two Sum II - Input Array Is Sorted",
    "description": "–ù–∞–π—Ç–∏ –∏–Ω–¥–µ–∫—Å—ã –¥–≤—É—Ö —á–∏—Å–µ–ª –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –º–∞—Å—Å–∏–≤–µ, –¥–∞—é—â–∏—Ö –≤ —Å—É–º–º–µ target.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Å –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞.",
    "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int left = 0, right = numbers.size() - 1;\n        \n        while (left < right) {\n            int sum = numbers[left] + numbers[right];\n            if (sum == target) {\n                return {left + 1, right + 1};\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return {};\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "058_two_sum_ii___input_array_is_sorted.cpp"
  },
  {
    "id": 59,
    "title": "Two Sum III - Data Structure Design",
    "description": "–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â—É—é –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —á–∏—Å–µ–ª –∏ –ø–æ–∏—Å–∫ –ø–∞—Ä —Å –∑–∞–¥–∞–Ω–Ω–æ–π —Å—É–º–º–æ–π.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—É –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞.",
    "code": "class TwoSum {\n    unordered_map<int, int> numCount;\npublic:\n    TwoSum() {}\n    \n    void add(int number) {\n        numCount[number]++;\n    }\n    \n    bool find(int value) {\n        for (auto& [num, count] : numCount) {\n            int complement = value - num;\n            if (complement != num) {\n                if (numCount.count(complement)) return true;\n            } else {\n                if (count > 1) return true;\n            }\n        }\n        return false;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "059_two_sum_iii___data_structure_design.cpp"
  },
  {
    "id": 60,
    "title": "Contains Duplicate",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏ –º–∞—Å—Å–∏–≤ –¥—É–±–ª–∏–∫–∞—Ç—ã.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–æ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
    "code": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_set<int> seen;\n        for (int num : nums) {\n            if (seen.count(num)) return true;\n            seen.insert(num);\n        }\n        return false;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "060_contains_duplicate.cpp"
  },
  {
    "id": 61,
    "title": "Rotate Array",
    "description": "–°–¥–≤–∏–Ω—É—Ç—å –º–∞—Å—Å–∏–≤ –≤–ø—Ä–∞–≤–æ –Ω–∞ k —à–∞–≥–æ–≤.",
    "idea": "–¢—Ä–∏ —Ä–µ–≤–µ—Ä—Å–∞: –≤–µ—Å—å –º–∞—Å—Å–∏–≤, –ø–µ—Ä–≤—ã–µ k —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –æ—Å—Ç–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã.",
    "code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k %= n;\n        \n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "061_rotate_array.cpp"
  },
  {
    "id": 62,
    "title": "3Sum Smaller",
    "description": "–ù–∞–π—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç—Ä–æ–µ–∫ —Å —Å—É–º–º–æ–π –º–µ–Ω—å—à–µ target.",
    "idea": "–°–æ—Ä—Ç–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –¥–ª—è –∫–∞–∂–¥–æ–π –ø–æ–∑–∏—Ü–∏–∏ i.",
    "code": "class Solution {\npublic:\n    int threeSumSmaller(vector<int>& nums, int target) {\n        if (nums.size() < 3) return 0;\n        \n        sort(nums.begin(), nums.end());\n        int count = 0;\n        \n        for (int i = 0; i < nums.size() - 2; i++) {\n            int left = i + 1, right = nums.size() - 1;\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                if (sum < target) {\n                    count += right - left;\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        return count;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "062_3sum_smaller.cpp"
  },
  {
    "id": 63,
    "title": "3Sum Closest",
    "description": "–ù–∞–π—Ç–∏ —Ç—Ä–æ–π–∫—É —Å —Å—É–º–º–æ–π, –Ω–∞–∏–±–æ–ª–µ–µ –±–ª–∏–∑–∫–æ–π –∫ target.",
    "idea": "–°–æ—Ä—Ç–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è, –æ—Ç—Å–ª–µ–∂–∏–≤–∞—è –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Ä–∞–∑–Ω–∏—Ü—É.",
    "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        int closestSum = nums[0] + nums[1] + nums[2];\n        \n        for (int i = 0; i < nums.size() - 2; i++) {\n            int left = i + 1, right = nums.size() - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                if (abs(sum - target) < abs(closestSum - target)) {\n                    closestSum = sum;\n                }\n                \n                if (sum < target) {\n                    left++;\n                } else if (sum > target) {\n                    right--;\n                } else {\n                    return sum;\n                }\n            }\n        }\n        return closestSum;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "063_3sum_closest.cpp"
  },
  {
    "id": 64,
    "title": "3Sum",
    "description": "–ù–∞–π—Ç–∏ –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ç—Ä–æ–π–∫–∏ —Å –Ω—É–ª–µ–≤–æ–π —Å—É–º–º–æ–π.",
    "idea": "–°–æ—Ä—Ç–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ –∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> result;\n        sort(nums.begin(), nums.end());\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            \n            int left = i + 1, right = nums.size() - 1;\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum == 0) {\n                    result.push_back({nums[i], nums[left], nums[right]});\n                    \n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    \n                    left++;\n                    right--;\n                } else if (sum < 0) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n        return result;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "064_3sum.cpp"
  },
  {
    "id": 65,
    "title": "Two Sum",
    "description": "–ù–∞–π—Ç–∏ –∏–Ω–¥–µ–∫—Å—ã –¥–≤—É—Ö —á–∏—Å–µ–ª, –¥–∞—é—â–∏—Ö –≤ —Å—É–º–º–µ target.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—É –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —á–∏—Å–µ–ª –∏ –∏—Ö –∏–Ω–¥–µ–∫—Å–æ–≤.",
    "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> numMap;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (numMap.count(complement)) {\n                return {numMap[complement], i};\n            }\n            numMap[nums[i]] = i;\n        }\n        return {};\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "065_two_sum.cpp"
  },
  {
    "id": 66,
    "title": "Plus One",
    "description": "–£–≤–µ–ª–∏—á–∏—Ç—å —á–∏—Å–ª–æ, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ –º–∞—Å—Å–∏–≤–æ–º —Ü–∏—Ñ—Ä, –Ω–∞ 1.",
    "idea": "–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–µ–Ω–æ—Å —Å –∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞.",
    "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size();\n        \n        for (int i = n - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        \n        digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "066_plus_one.cpp"
  },
  {
    "id": 67,
    "title": "Best Time to Buy and Sell Stock",
    "description": "–ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø—Ä–∏–±—ã–ª—å –æ—Ç –æ–¥–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–æ–∫—É–ø–∫–∏/–ø—Ä–æ–¥–∞–∂–∏ –∞–∫—Ü–∏–π.",
    "idea": "–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Ü–µ–Ω—É –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø—Ä–∏–±—ã–ª—å.",
    "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int minPrice = INT_MAX;\n        int maxProfit = 0;\n        \n        for (int price : prices) {\n            minPrice = min(minPrice, price);\n            maxProfit = max(maxProfit, price - minPrice);\n        }\n        return maxProfit;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "067_best_time_to_buy_and_sell_stock.cpp"
  },
  {
    "id": 68,
    "title": "Shortest Word Distance",
    "description": "–ù–∞–π—Ç–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –¥–≤—É–º—è —Å–ª–æ–≤–∞–º–∏ –≤ –º–∞—Å—Å–∏–≤–µ.",
    "idea": "–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –æ–±–æ–∏—Ö —Å–ª–æ–≤ –∏ –≤—ã—á–∏—Å–ª—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Ä–∞–∑–Ω–∏—Ü—É.",
    "code": "class Solution {\npublic:\n    int shortestDistance(vector<string>& words, string word1, string word2) {\n        int pos1 = -1, pos2 = -1;\n        int minDist = INT_MAX;\n        \n        for (int i = 0; i < words.size(); i++) {\n            if (words[i] == word1) {\n                pos1 = i;\n            } else if (words[i] == word2) {\n                pos2 = i;\n            }\n            \n            if (pos1 != -1 && pos2 != -1) {\n                minDist = min(minDist, abs(pos1 - pos2));\n            }\n        }\n        return minDist;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "068_shortest_word_distance.cpp"
  },
  {
    "id": 69,
    "title": "Move Zeroes",
    "description": "–ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤—Å–µ –Ω—É–ª–∏ –≤ –∫–æ–Ω–µ—Ü –º–∞—Å—Å–∏–≤–∞, —Å–æ—Ö—Ä–∞–Ω—è—è –ø–æ—Ä—è–¥–æ–∫ –Ω–µ–Ω—É–ª–µ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è: –æ–¥–∏–Ω –¥–ª—è —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏, –¥—Ä—É–≥–æ–π –¥–ª—è –ø–æ–∏—Å–∫–∞ –Ω–µ–Ω—É–ª–µ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
    "code": "class Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int nonZeroPos = 0;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != 0) {\n                swap(nums[nonZeroPos++], nums[i]);\n            }\n        }\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "069_move_zeroes.cpp"
  },
  {
    "id": 70,
    "title": "Contains Duplicate II",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –µ—Å—Ç—å –ª–∏ –¥—É–±–ª–∏–∫–∞—Ç—ã –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –Ω–µ –±–æ–ª–µ–µ k.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ —Å —Ö—ç—à-—Ç–∞–±–ª–∏—Ü–µ–π.",
    "code": "class Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int, int> numIndex;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (numIndex.count(nums[i]) && i - numIndex[nums[i]] <= k) {\n                return true;\n            }\n            numIndex[nums[i]] = i;\n        }\n        return false;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "070_contains_duplicate_ii.cpp"
  },
  {
    "id": 71,
    "title": "Majority Element",
    "description": "–ù–∞–π—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç, –≤—Å—Ç—Ä–µ—á–∞—é—â–∏–π—Å—è –±–æ–ª–µ–µ n/2 —Ä–∞–∑.",
    "idea": "–ê–ª–≥–æ—Ä–∏—Ç–º –ë–æ–π–µ—Ä–∞-–ú—É—Ä–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ majority —ç–ª–µ–º–µ–Ω—Ç–∞.",
    "code": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int candidate = nums[0];\n        int count = 1;\n        \n        for (int i = 1; i < nums.size(); i++) {\n            if (count == 0) {\n                candidate = nums[i];\n                count = 1;\n            } else if (nums[i] == candidate) {\n                count++;\n            } else {\n                count--;\n            }\n        }\n        return candidate;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "071_majority_element.cpp"
  },
  {
    "id": 72,
    "title": "Remove Duplicates from Sorted Array",
    "description": "–£–¥–∞–ª–∏—Ç—å –¥—É–±–ª–∏–∫–∞—Ç—ã –∏–∑ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –º–∞—Å—Å–∏–≤–∞ –Ω–∞ –º–µ—Å—Ç–µ.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è: –æ–¥–∏–Ω –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –¥—Ä—É–≥–æ–π –¥–ª—è –æ–±—Ö–æ–¥–∞ –º–∞—Å—Å–∏–≤–∞.",
    "code": "class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        \n        int uniquePos = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] != nums[uniquePos]) {\n                nums[++uniquePos] = nums[i];\n            }\n        }\n        return uniquePos + 1;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "072_remove_duplicates_from_sorted_array.cpp"
  },
  {
    "id": 73,
    "title": "Nested List Weight Sum",
    "description": "–í—ã—á–∏—Å–ª–∏—Ç—å –≤–∑–≤–µ—à–µ–Ω–Ω—É—é —Å—É–º–º—É –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª.",
    "idea": "–†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π DFS —Å –ø–µ—Ä–µ–¥–∞—á–µ–π —Ç–µ–∫—É—â–µ–π –≥–ª—É–±–∏–Ω—ã.",
    "code": "class Solution {\npublic:\n    int depthSum(vector<NestedInteger>& nestedList) {\n        return dfs(nestedList, 1);\n    }\n    \n    int dfs(vector<NestedInteger>& nestedList, int depth) {\n        int sum = 0;\n        for (auto& ni : nestedList) {\n            if (ni.isInteger()) {\n                sum += ni.getInteger() * depth;\n            } else {\n                sum += dfs(ni.getList(), depth + 1);\n            }\n        }\n        return sum;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "073_nested_list_weight_sum.cpp"
  },
  {
    "id": 74,
    "title": "Nested List Weight Sum II",
    "description": "–í—ã—á–∏—Å–ª–∏—Ç—å –≤–∑–≤–µ—à–µ–Ω–Ω—É—é —Å—É–º–º—É —Å –≤–µ—Å–∞–º–∏ –æ—Ç –ª–∏—Å—Ç—å–µ–≤ –∫ –∫–æ—Ä–Ω—é.",
    "idea": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ö–æ–¥–∏–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –≥–ª—É–±–∏–Ω—É, –∑–∞—Ç–µ–º –≤—ã—á–∏—Å–ª—è–µ–º —Å—É–º–º—É —Å –æ–±—Ä–∞—Ç–Ω—ã–º–∏ –≤–µ—Å–∞–º–∏.",
    "code": "class Solution {\npublic:\n    int depthSumInverse(vector<NestedInteger>& nestedList) {\n        int maxDepth = getMaxDepth(nestedList);\n        return dfs(nestedList, maxDepth);\n    }\n    \n    int getMaxDepth(vector<NestedInteger>& nestedList) {\n        int maxDepth = 1;\n        for (auto& ni : nestedList) {\n            if (!ni.isInteger()) {\n                maxDepth = max(maxDepth, 1 + getMaxDepth(ni.getList()));\n            }\n        }\n        return maxDepth;\n    }\n    \n    int dfs(vector<NestedInteger>& nestedList, int depth) {\n        int sum = 0;\n        for (auto& ni : nestedList) {\n            if (ni.isInteger()) {\n                sum += ni.getInteger() * depth;\n            } else {\n                sum += dfs(ni.getList(), depth - 1);\n            }\n        }\n        return sum;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "074_nested_list_weight_sum_ii.cpp"
  },
  {
    "id": 75,
    "title": "Remove Element",
    "description": "–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –≤—Ö–æ–∂–¥–µ–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–∞ –∏–∑ –º–∞—Å—Å–∏–≤–∞ –Ω–∞ –º–µ—Å—Ç–µ.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è: –æ–¥–∏–Ω –¥–ª—è —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏, –¥—Ä—É–≥–æ–π –¥–ª—è –æ–±—Ö–æ–¥–∞ –º–∞—Å—Å–∏–≤–∞.",
    "code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int newPos = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != val) {\n                nums[newPos++] = nums[i];\n            }\n        }\n        return newPos;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "075_remove_element.cpp"
  },
  {
    "id": 76,
    "title": "Intersection of Two Arrays II",
    "description": "–ù–∞–π—Ç–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –¥–≤—É—Ö –º–∞—Å—Å–∏–≤–æ–≤ —Å —É—á–µ—Ç–æ–º –∫—Ä–∞—Ç–Ω–æ—Å—Ç–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
    "idea": "–°–æ—Ä—Ç–∏—Ä—É–µ–º –æ–±–∞ –º–∞—Å—Å–∏–≤–∞ –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è.",
    "code": "class Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        sort(nums1.begin(), nums1.end());\n        sort(nums2.begin(), nums2.end());\n        \n        vector<int> result;\n        int i = 0, j = 0;\n        \n        while (i < nums1.size() && j < nums2.size()) {\n            if (nums1[i] == nums2[j]) {\n                result.push_back(nums1[i]);\n                i++;\n                j++;\n            } else if (nums1[i] < nums2[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n        return result;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "076_intersection_of_two_arrays_ii.cpp"
  },
  {
    "id": 77,
    "title": "Merge Sorted Arrays",
    "description": "–û–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–∞—Å—Å–∏–≤–∞ –≤ –ø–µ—Ä–≤—ã–π –º–∞—Å—Å–∏–≤.",
    "idea": "–ó–∞–ø–æ–ª–Ω—è–µ–º —Å –∫–æ–Ω—Ü–∞, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã.",
    "code": "class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n        \n        while (i >= 0 && j >= 0) {\n            if (nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n        \n        while (j >= 0) {\n            nums1[k--] = nums2[j--];\n        }\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "077_merge_sorted_arrays.cpp"
  },
  {
    "id": 78,
    "title": "Reverse Vowels of a String",
    "description": "–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Ç–æ–ª—å–∫–æ –≥–ª–∞—Å–Ω—ã–µ –≤ —Å—Ç—Ä–æ–∫–µ.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Å –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞, –º–µ–Ω—è–µ–º –≥–ª–∞—Å–Ω—ã–µ –º–µ—Å—Ç–∞–º–∏.",
    "code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        int left = 0, right = s.size() - 1;\n        \n        while (left < right) {\n            while (left < right && !vowels.count(s[left])) left++;\n            while (left < right && !vowels.count(s[right])) right--;\n            \n            if (left < right) {\n                swap(s[left], s[right]);\n                left++;\n                right--;\n            }\n        }\n        return s;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "078_reverse_vowels_of_a_string.cpp"
  },
  {
    "id": 79,
    "title": "Intersection of Two Arrays",
    "description": "–ù–∞–π—Ç–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –¥–≤—É—Ö –º–∞—Å—Å–∏–≤–æ–≤ (—É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã).",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤.",
    "code": "class Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int> set1(nums1.begin(), nums1.end());\n        unordered_set<int> result;\n        \n        for (int num : nums2) {\n            if (set1.count(num)) {\n                result.insert(num);\n            }\n        }\n        return vector<int>(result.begin(), result.end());\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "079_intersection_of_two_arrays.cpp"
  },
  {
    "id": 80,
    "title": "Container With Most Water",
    "description": "–ù–∞–π—Ç–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π –ø–ª–æ—â–∞–¥—å—é.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Å –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞, –¥–≤–∏–≥–∞–µ–º —Ç–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –≤—ã—Å–æ—Ç—É.",
    "code": "class Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left = 0, right = height.size() - 1;\n        int maxArea = 0;\n        \n        while (left < right) {\n            int area = min(height[left], height[right]) * (right - left);\n            maxArea = max(maxArea, area);\n            \n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return maxArea;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "080_container_with_most_water.cpp"
  },
  {
    "id": 81,
    "title": "Product of Array Except Self",
    "description": "–í—ã—á–∏—Å–ª–∏—Ç—å –º–∞—Å—Å–∏–≤, –≥–¥–µ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç - –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫—Ä–æ–º–µ —Å–µ–±—è.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ—Ñ–∏–∫—Å–Ω—ã–µ –∏ –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω—ã–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è.",
    "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n, 1);\n        \n        // –ü—Ä–µ—Ñ–∏–∫—Å–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ\n        int prefix = 1;\n        for (int i = 0; i < n; i++) {\n            result[i] = prefix;\n            prefix *= nums[i];\n        }\n        \n        // –ü–æ—Å—Ç—Ñ–∏–∫—Å–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ\n        int postfix = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            result[i] *= postfix;\n            postfix *= nums[i];\n        }\n        \n        return result;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "081_product_of_array_except_self.cpp"
  },
  {
    "id": 82,
    "title": "Trapping Rain Water",
    "description": "–í—ã—á–∏—Å–ª–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–¥—ã, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –∑–∞–¥–µ—Ä–∂–∞—Ç—å—Å—è –º–µ–∂–¥—É —Å—Ç–æ–ª–±—Ü–∞–º–∏.",
    "idea": "–î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞ –≤—ã—á–∏—Å–ª—è–µ–º min(–º–∞–∫—Å_—Å–ª–µ–≤–∞, –º–∞–∫—Å_—Å–ø—Ä–∞–≤–∞) - –≤—ã—Å–æ—Ç–∞_—Å—Ç–æ–ª–±—Ü–∞.",
    "code": "class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int n = height.size();\n        if (n == 0) return 0;\n        \n        vector<int> leftMax(n), rightMax(n);\n        \n        leftMax[0] = height[0];\n        for (int i = 1; i < n; i++) {\n            leftMax[i] = max(leftMax[i - 1], height[i]);\n        }\n        \n        rightMax[n - 1] = height[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            rightMax[i] = max(rightMax[i + 1], height[i]);\n        }\n        \n        int water = 0;\n        for (int i = 0; i < n; i++) {\n            water += min(leftMax[i], rightMax[i]) - height[i];\n        }\n        return water;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "082_trapping_rain_water.cpp"
  },
  {
    "id": 83,
    "title": "Maximum Subarray",
    "description": "–ù–∞–π—Ç–∏ –ø–æ–¥–º–∞—Å—Å–∏–≤ —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å—É–º–º–æ–π.",
    "idea": "–ê–ª–≥–æ—Ä–∏—Ç–º –ö–∞–¥–∞–Ω–µ - –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é —Å—É–º–º—É –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É.",
    "code": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        \n        for (int i = 1; i < nums.size(); i++) {\n            currentSum = max(nums[i], currentSum + nums[i]);\n            maxSum = max(maxSum, currentSum);\n        }\n        return maxSum;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "083_maximum_subarray.cpp"
  },
  {
    "id": 84,
    "title": "Best Time to Buy and Sell Stock II",
    "description": "–ú–∞–∫—Å–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–±—ã–ª—å –æ—Ç –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π.",
    "idea": "–°—É–º–º–∏—Ä—É–µ–º –≤—Å–µ –≤–æ–∑—Ä–∞—Å—Ç–∞—é—â–∏–µ —Ä–∞–∑–Ω–∏—Ü—ã –º–µ–∂–¥—É —Å–æ—Å–µ–¥–Ω–∏–º–∏ –¥–Ω—è–º–∏.",
    "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int profit = 0;\n        for (int i = 1; i < prices.size(); i++) {\n            if (prices[i] > prices[i - 1]) {\n                profit += prices[i] - prices[i - 1];\n            }\n        }\n        return profit;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "084_best_time_to_buy_and_sell_stock_ii.cpp"
  },
  {
    "id": 85,
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "–ù–∞–π—Ç–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –≤ rotated sorted array.",
    "idea": "–ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –±–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫.",
    "code": "class Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int left = 0, right = nums.size() - 1;\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] > nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return nums[left];\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "085_find_minimum_in_rotated_sorted_array.cpp"
  },
  {
    "id": 86,
    "title": "Pascal's Triangle",
    "description": "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ü–∞—Å–∫–∞–ª—è –¥–æ n-–π —Å—Ç—Ä–æ–∫–∏.",
    "idea": "–ö–∞–∂–¥–æ–µ —á–∏—Å–ª–æ —Ä–∞–≤–Ω–æ —Å—É–º–º–µ –¥–≤—É—Ö —á–∏—Å–µ–ª –Ω–∞–¥ –Ω–∏–º.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> triangle;\n        \n        for (int i = 0; i < numRows; i++) {\n            vector<int> row(i + 1, 1);\n            \n            for (int j = 1; j < i; j++) {\n                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];\n            }\n            \n            triangle.push_back(row);\n        }\n        return triangle;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "086_pascal_s_triangle.cpp"
  },
  {
    "id": 87,
    "title": "Pascal's Triangle II",
    "description": "–í–µ—Ä–Ω—É—Ç—å k-—é —Å—Ç—Ä–æ–∫—É —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –ü–∞—Å–∫–∞–ª—è.",
    "idea": "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫—É –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É—è —Ç–æ–ª—å–∫–æ O(k) –ø–∞–º—è—Ç–∏.",
    "code": "class Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<int> row(rowIndex + 1, 1);\n        \n        for (int i = 1; i <= rowIndex; i++) {\n            for (int j = i - 1; j > 0; j--) {\n                row[j] = row[j] + row[j - 1];\n            }\n        }\n        return row;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "087_pascal_s_triangle_ii.cpp"
  },
  {
    "id": 88,
    "title": "Summary Ranges",
    "description": "–°—É–º–º–∏—Ä–æ–≤–∞—Ç—å –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ –≤ –¥–∏–∞–ø–∞–∑–æ–Ω—ã.",
    "idea": "–ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –º–∞—Å—Å–∏–≤—É –∏ —Ñ–æ—Ä–º–∏—Ä—É–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω—ã –∏–∑ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª.",
    "code": "class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> result;\n        int n = nums.size();\n        \n        for (int i = 0; i < n; i++) {\n            int start = nums[i];\n            \n            while (i + 1 < n && nums[i + 1] == nums[i] + 1) {\n                i++;\n            }\n            \n            if (start == nums[i]) {\n                result.push_back(to_string(start));\n            } else {\n                result.push_back(to_string(start) + \"->\" + to_string(nums[i]));\n            }\n        }\n        return result;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "088_summary_ranges.cpp"
  },
  {
    "id": 89,
    "title": "Missing Number",
    "description": "–ù–∞–π—Ç–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ –≤ –º–∞—Å—Å–∏–≤–µ [0, n].",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º XOR –∏–ª–∏ —Å—É–º–º—É –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≥—Ä–µ—Å—Å–∏–∏.",
    "code": "class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n        int expectedSum = n * (n + 1) / 2;\n        int actualSum = 0;\n        \n        for (int num : nums) {\n            actualSum += num;\n        }\n        \n        return expectedSum - actualSum;\n    }\n};",
    "category": "Arrays",
    "difficulty": "Easy",
    "filename": "089_missing_number.cpp"
  },
  {
    "id": 90,
    "title": "Valid Anagram",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è—é—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∏ –∞–Ω–∞–≥—Ä–∞–º–º–∞–º–∏.",
    "idea": "–°—á–∏—Ç–∞–µ–º —á–∞—Å—Ç–æ—Ç—ã —Å–∏–º–≤–æ–ª–æ–≤ –∏–ª–∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏.",
    "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.length() != t.length()) return false;\n        \n        vector<int> count(26, 0);\n        for (char c : s) count[c - 'a']++;\n        for (char c : t) {\n            if (--count[c - 'a'] < 0) return false;\n        }\n        return true;\n    }\n};",
    "category": "Strings",
    "difficulty": "Easy",
    "filename": "090_valid_anagram.cpp"
  },
  {
    "id": 91,
    "title": "Valid Palindrome",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–º, –∏–≥–Ω–æ—Ä–∏—Ä—É—è –Ω–µ-–±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤—ã–µ —Å–∏–º–≤–æ–ª—ã.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π —Å–∏–º–≤–æ–ª–æ–≤.",
    "code": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            while (left < right && !isalnum(s[left])) left++;\n            while (left < right && !isalnum(s[right])) right--;\n            \n            if (tolower(s[left]) != tolower(s[right])) return false;\n            \n            left++;\n            right--;\n        }\n        return true;\n    }\n};",
    "category": "Strings",
    "difficulty": "Easy",
    "filename": "091_valid_palindrome.cpp"
  },
  {
    "id": 92,
    "title": "Word Pattern",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ª–∏ —Å—Ç—Ä–æ–∫–∞ —à–∞–±–ª–æ–Ω—É.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–≤–∞ —Ö—ç—à–∞ –¥–ª—è –≤–∑–∞–∏–º–Ω–æ-–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–≥–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è.",
    "code": "class Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        unordered_map<char, string> charToWord;\n        unordered_map<string, char> wordToChar;\n        \n        stringstream ss(s);\n        string word;\n        int i = 0;\n        \n        while (ss >> word) {\n            if (i >= pattern.length()) return false;\n            \n            char c = pattern[i];\n            \n            if (charToWord.count(c) && charToWord[c] != word) return false;\n            if (wordToChar.count(word) && wordToChar[word] != c) return false;\n            \n            charToWord[c] = word;\n            wordToChar[word] = c;\n            i++;\n        }\n        \n        return i == pattern.length();\n    }\n};",
    "category": "Strings",
    "difficulty": "Easy",
    "filename": "092_word_pattern.cpp"
  },
  {
    "id": 93,
    "title": "Valid Parentheses",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Å–∫–æ–±–æ—á–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—Ç–µ–∫ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö —Å–∫–æ–±–æ–∫.",
    "code": "class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        unordered_map<char, char> pairs = {\n            {')', '('}, {']', '['}, {'}', '{'}\n        };\n        \n        for (char c : s) {\n            if (pairs.count(c)) {\n                if (st.empty() || st.top() != pairs[c]) return false;\n                st.pop();\n            } else {\n                st.push(c);\n            }\n        }\n        return st.empty();\n    }\n};",
    "category": "Strings",
    "difficulty": "Easy",
    "filename": "093_valid_parentheses.cpp"
  },
  {
    "id": 94,
    "title": "Isomorphic Strings",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è—é—Ç—Å—è –ª–∏ —Å—Ç—Ä–æ–∫–∏ –∏–∑–æ–º–æ—Ä—Ñ–Ω—ã–º–∏.",
    "idea": "–ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∑–∞–∏–º–Ω–æ-–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Å–∏–º–≤–æ–ª–æ–≤.",
    "code": "class Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        unordered_map<char, char> sToT;\n        unordered_map<char, char> tToS;\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c1 = s[i], c2 = t[i];\n            \n            if (sToT.count(c1) && sToT[c1] != c2) return false;\n            if (tToS.count(c2) && tToS[c2] != c1) return false;\n            \n            sToT[c1] = c2;\n            tToS[c2] = c1;\n        }\n        return true;\n    }\n};",
    "category": "Strings",
    "difficulty": "Easy",
    "filename": "094_isomorphic_strings.cpp"
  },
  {
    "id": 95,
    "title": "Reverse String",
    "description": "–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Å—Ç—Ä–æ–∫—É –Ω–∞ –º–µ—Å—Ç–µ.",
    "idea": "–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è —Å –Ω–∞—á–∞–ª–∞ –∏ –∫–æ–Ω—Ü–∞.",
    "code": "class Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        int left = 0, right = s.size() - 1;\n        while (left < right) {\n            swap(s[left++], s[right--]);\n        }\n    }\n};",
    "category": "Strings",
    "difficulty": "Easy",
    "filename": "095_reverse_string.cpp"
  },
  {
    "id": 96,
    "title": "Sum of Two Integers",
    "description": "–°–ª–æ–∂–∏—Ç—å –¥–≤–∞ —Ü–µ–ª—ã—Ö —á–∏—Å–ª–∞ –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è + –∏ -.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–±–∏—Ç–æ–≤—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ XOR –¥–ª—è —Å—É–º–º—ã –∏ AND –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞.",
    "code": "class Solution {\npublic:\n    int getSum(int a, int b) {\n        while (b != 0) {\n            int carry = a & b;\n            a = a ^ b;\n            b = (unsigned)carry << 1;\n        }\n        return a;\n    }\n};",
    "category": "Bit Manipulation",
    "difficulty": "Medium",
    "filename": "096_sum_of_two_integers.cpp"
  },
  {
    "id": 97,
    "title": "Single Number",
    "description": "–ù–∞–π—Ç–∏ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ, –≤—Å—Ç—Ä–µ—á–∞—é—â–µ–µ—Å—è –æ–¥–∏–Ω —Ä–∞–∑ –≤ –º–∞—Å—Å–∏–≤–µ.",
    "idea": "XOR –≤—Å–µ—Ö —á–∏—Å–µ–ª - –¥—É–±–ª–∏–∫–∞—Ç—ã —É–Ω–∏—á—Ç–æ–∂–∞—Ç—Å—è.",
    "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int result = 0;\n        for (int num : nums) result ^= num;\n        return result;\n    }\n};",
    "category": "Bit Manipulation",
    "difficulty": "Medium",
    "filename": "097_single_number.cpp"
  },
  {
    "id": 98,
    "title": "Single Number II",
    "description": "–ù–∞–π—Ç–∏ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ —á–∏—Å–ª–æ, –≤—Å—Ç—Ä–µ—á–∞—é—â–µ–µ—Å—è –æ–¥–∏–Ω —Ä–∞–∑, –æ—Å—Ç–∞–ª—å–Ω—ã–µ - —Ç—Ä–∏ —Ä–∞–∑–∞.",
    "idea": "–°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –µ–¥–∏–Ω–∏—Ü –≤ –∫–∞–∂–¥–æ–º –±–∏—Ç–µ –ø–æ –º–æ–¥—É–ª—é 3.",
    "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ones = 0, twos = 0;\n        for (int num : nums) {\n            ones = (ones ^ num) & ~twos;\n            twos = (twos ^ num) & ~ones;\n        }\n        return ones;\n    }\n};",
    "category": "Bit Manipulation",
    "difficulty": "Medium",
    "filename": "098_single_number_ii.cpp"
  },
  {
    "id": 99,
    "title": "Single Number III",
    "description": "–ù–∞–π—Ç–∏ –¥–≤–∞ —á–∏—Å–ª–∞, –≤—Å—Ç—Ä–µ—á–∞—é—â–∏—Ö—Å—è –ø–æ –æ–¥–Ω–æ–º—É —Ä–∞–∑—É.",
    "idea": "–ù–∞—Ö–æ–¥–∏–º —Ä–∞–∑–ª–∏—á–∞—é—â–∏–π –±–∏—Ç –∏ —Ä–∞–∑–¥–µ–ª—è–µ–º —á–∏—Å–ª–∞ –Ω–∞ –¥–≤–µ –≥—Ä—É–ø–ø—ã.",
    "code": "class Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        long diff = 0;\n        for (int num : nums) diff ^= num;\n        \n        diff &= -diff; // –ù–∞—Ö–æ–¥–∏–º –º–ª–∞–¥—à–∏–π —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –±–∏—Ç\n        \n        vector<int> result(2, 0);\n        for (int num : nums) {\n            if (num & diff) {\n                result[0] ^= num;\n            } else {\n                result[1] ^= num;\n            }\n        }\n        return result;\n    }\n};",
    "category": "Bit Manipulation",
    "difficulty": "Medium",
    "filename": "099_single_number_iii.cpp"
  },
  {
    "id": 100,
    "title": "Reverse Integer",
    "description": "–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å —Ü–∏—Ñ—Ä—ã —Ü–µ–ª–æ–≥–æ —á–∏—Å–ª–∞.",
    "idea": "–ü–æ—Ä–∞–∑—Ä—è–¥–Ω–æ –∏–∑–≤–ª–µ–∫–∞–µ–º —Ü–∏—Ñ—Ä—ã –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ.",
    "code": "class Solution {\npublic:\n    int reverse(int x) {\n        int result = 0;\n        \n        while (x != 0) {\n            int digit = x % 10;\n            x /= 10;\n            \n            if (result > INT_MAX/10 || (result == INT_MAX/10 && digit > 7)) return 0;\n            if (result < INT_MIN/10 || (result == INT_MIN/10 && digit < -8)) return 0;\n            \n            result = result * 10 + digit;\n        }\n        return result;\n    }\n};",
    "category": "Maths",
    "difficulty": "Medium",
    "filename": "100_reverse_integer.cpp"
  },
  {
    "id": 101,
    "title": "Palindrome Number",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–æ–º.",
    "idea": "–†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –ø–æ–ª–æ–≤–∏–Ω—É —á–∏—Å–ª–∞ –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –æ—Å—Ç–∞–≤—à–µ–π—Å—è –ø–æ–ª–æ–≤–∏–Ω–æ–π.",
    "code": "class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0 || (x % 10 == 0 && x != 0)) return false;\n        \n        int reversed = 0;\n        while (x > reversed) {\n            reversed = reversed * 10 + x % 10;\n            x /= 10;\n        }\n        \n        return x == reversed || x == reversed / 10;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "101_palindrome_number.cpp"
  },
  {
    "id": 102,
    "title": "Pow(x, n)",
    "description": "–í—ã—á–∏—Å–ª–∏—Ç—å x –≤ —Å—Ç–µ–ø–µ–Ω–∏ n.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –±—ã—Å—Ç—Ä–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å —á–µ—Ä–µ–∑ –¥–≤–æ–∏—á–Ω–æ–µ —Ä–∞–∑–ª–æ–∂–µ–Ω–∏–µ.",
    "code": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        long long N = n;\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        \n        double result = 1.0;\n        double current = x;\n        \n        for (long long i = N; i > 0; i /= 2) {\n            if (i % 2 == 1) {\n                result *= current;\n            }\n            current *= current;\n        }\n        return result;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "102_pow_x__n_.cpp"
  },
  {
    "id": 103,
    "title": "Subsets",
    "description": "–ù–∞–π—Ç–∏ –≤—Å–µ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –±–∏—Ç–æ–≤—ã–µ –º–∞—Å–∫–∏ –∏–ª–∏ backtracking.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> result;\n        int n = nums.size();\n        int total = 1 << n;\n        \n        for (int mask = 0; mask < total; mask++) {\n            vector<int> subset;\n            for (int i = 0; i < n; i++) {\n                if (mask & (1 << i)) {\n                    subset.push_back(nums[i]);\n                }\n            }\n            result.push_back(subset);\n        }\n        return result;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "103_subsets.cpp"
  },
  {
    "id": 104,
    "title": "Subsets II",
    "description": "–ù–∞–π—Ç–∏ –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ —Å –¥—É–±–ª–∏–∫–∞—Ç–∞–º–∏.",
    "idea": "–°–æ—Ä—Ç–∏—Ä—É–µ–º –∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º backtracking, –ø—Ä–æ–ø—É—Å–∫–∞—è –¥—É–±–ª–∏–∫–∞—Ç—ã.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> result;\n        vector<int> current;\n        backtrack(nums, 0, current, result);\n        return result;\n    }\n    \n    void backtrack(vector<int>& nums, int start, vector<int>& current, vector<vector<int>>& result) {\n        result.push_back(current);\n        \n        for (int i = start; i < nums.size(); i++) {\n            if (i > start && nums[i] == nums[i - 1]) continue;\n            \n            current.push_back(nums[i]);\n            backtrack(nums, i + 1, current, result);\n            current.pop_back();\n        }\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "104_subsets_ii.cpp"
  },
  {
    "id": 105,
    "title": "Fraction to Recurring Decimal",
    "description": "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –¥—Ä–æ–±—å –≤ —Å—Ç—Ä–æ–∫—É —Å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –¥—Ä–æ–±—å—é.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –æ—Å—Ç–∞—Ç–∫–æ–≤ –∏ –≤—ã—è–≤–ª–µ–Ω–∏—è —Ü–∏–∫–ª–æ–≤.",
    "code": "class Solution {\npublic:\n    string fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) return \"0\";\n        \n        string result;\n        // –ó–Ω–∞–∫\n        if (numerator < 0 ^ denominator < 0) {\n            result += '-';\n        }\n        \n        long num = labs(numerator);\n        long den = labs(denominator);\n        \n        // –¶–µ–ª–∞—è —á–∞—Å—Ç—å\n        result += to_string(num / den);\n        long remainder = num % den;\n        if (remainder == 0) return result;\n        \n        // –î—Ä–æ–±–Ω–∞—è —á–∞—Å—Ç—å\n        result += '.';\n        unordered_map<long, int> remainderPos;\n        \n        while (remainder != 0) {\n            if (remainderPos.count(remainder)) {\n                result.insert(remainderPos[remainder], \"(\");\n                result += ')';\n                break;\n            }\n            \n            remainderPos[remainder] = result.size();\n            remainder *= 10;\n            result += to_string(remainder / den);\n            remainder %= den;\n        }\n        \n        return result;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "105_fraction_to_recurring_decimal.cpp"
  },
  {
    "id": 106,
    "title": "Excel Sheet Column Number",
    "description": "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞ Excel –≤ —á–∏—Å–ª–æ.",
    "idea": "–†–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º –∫–∞–∫ —á–∏—Å–ª–æ –≤ 26-—Ä–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ —Å—á–∏—Å–ª–µ–Ω–∏—è.",
    "code": "class Solution {\npublic:\n    int titleToNumber(string columnTitle) {\n        int result = 0;\n        for (char c : columnTitle) {\n            result = result * 26 + (c - 'A' + 1);\n        }\n        return result;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "106_excel_sheet_column_number.cpp"
  },
  {
    "id": 107,
    "title": "Excel Sheet Column Title",
    "description": "–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —á–∏—Å–ª–æ –≤ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å—Ç–æ–ª–±—Ü–∞ Excel.",
    "idea": "–û–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏–∑ 26-—Ä–∏—á–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã —Å —É—á–µ—Ç–æ–º —Ç–æ–≥–æ, —á—Ç–æ –Ω–µ—Ç –Ω—É–ª—è.",
    "code": "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        string result;\n        \n        while (columnNumber > 0) {\n            columnNumber--;\n            result = char('A' + columnNumber % 26) + result;\n            columnNumber /= 26;\n        }\n        \n        return result;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "107_excel_sheet_column_title.cpp"
  },
  {
    "id": 108,
    "title": "Factorial Trailing Zeroes",
    "description": "–ù–∞–π—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω—É–ª–µ–π –≤ –∫–æ–Ω—Ü–µ n!.",
    "idea": "–°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–Ω–æ–∂–∏—Ç–µ–ª–µ–π 5 (—Ç–∞–∫ –∫–∞–∫ 2 –≤—Å–µ–≥–¥–∞ –±–æ–ª—å—à–µ).",
    "code": "class Solution {\npublic:\n    int trailingZeroes(int n) {\n        int count = 0;\n        while (n > 0) {\n            n /= 5;\n            count += n;\n        }\n        return count;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "108_factorial_trailing_zeroes.cpp"
  },
  {
    "id": 109,
    "title": "Happy Number",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —á–∏—Å–ª–æ \"—Å—á–∞—Å—Ç–ª–∏–≤—ã–º\".",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –∞–ª–≥–æ—Ä–∏—Ç–º –§–ª–æ–π–¥–∞ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Ü–∏–∫–ª–æ–≤.",
    "code": "class Solution {\npublic:\n    bool isHappy(int n) {\n        int slow = n, fast = getNext(n);\n        \n        while (fast != 1 && slow != fast) {\n            slow = getNext(slow);\n            fast = getNext(getNext(fast));\n        }\n        \n        return fast == 1;\n    }\n    \n    int getNext(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            sum += digit * digit;\n            n /= 10;\n        }\n        return sum;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "109_happy_number.cpp"
  },
  {
    "id": 110,
    "title": "Count Primes",
    "description": "–ü–æ–¥—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –º–µ–Ω—å—à–µ n.",
    "idea": "–†–µ—à–µ—Ç–æ –≠—Ä–∞—Ç–æ—Å—Ñ–µ–Ω–∞.",
    "code": "class Solution {\npublic:\n    int countPrimes(int n) {\n        if (n <= 2) return 0;\n        \n        vector<bool> isPrime(n, true);\n        isPrime[0] = isPrime[1] = false;\n        \n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) count++;\n        }\n        return count;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "110_count_primes.cpp"
  },
  {
    "id": 111,
    "title": "Plus One",
    "description": "–£–≤–µ–ª–∏—á–∏—Ç—å —á–∏—Å–ª–æ, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ –º–∞—Å—Å–∏–≤–æ–º —Ü–∏—Ñ—Ä, –Ω–∞ 1.",
    "idea": "–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–µ–Ω–æ—Å —Å –∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞.",
    "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n = digits.size();\n        \n        for (int i = n - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n        \n        digits.insert(digits.begin(), 1);\n        return digits;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "111_plus_one.cpp"
  },
  {
    "id": 112,
    "title": "Divide Two Integers",
    "description": "–†–∞–∑–¥–µ–ª–∏—Ç—å –¥–≤–∞ —Ü–µ–ª—ã—Ö —á–∏—Å–ª–∞ –±–µ–∑ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —É–º–Ω–æ–∂–µ–Ω–∏—è, –¥–µ–ª–µ–Ω–∏—è –∏ mod.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–±–∏—Ç–æ–≤—ã–µ —Å–¥–≤–∏–≥–∏ –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –¥–µ–ª–µ–Ω–∏—è.",
    "code": "class Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        if (dividend == INT_MIN && divisor == -1) return INT_MAX;\n        \n        long dvd = labs(dividend), dvs = labs(divisor);\n        int sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\n        \n        long result = 0;\n        while (dvd >= dvs) {\n            long temp = dvs, multiple = 1;\n            while (dvd >= (temp << 1)) {\n                temp <<= 1;\n                multiple <<= 1;\n            }\n            dvd -= temp;\n            result += multiple;\n        }\n        \n        return sign * result;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "112_divide_two_integers.cpp"
  },
  {
    "id": 113,
    "title": "Multiply Strings",
    "description": "–£–º–Ω–æ–∂–∏—Ç—å –¥–≤–∞ —á–∏—Å–ª–∞, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –∫–∞–∫ —Å—Ç—Ä–æ–∫–∏.",
    "idea": "–ò–º–∏—Ç–∏—Ä—É–µ–º —É–º–Ω–æ–∂–µ–Ω–∏–µ –≤ —Å—Ç–æ–ª–±–∏–∫.",
    "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") return \"0\";\n        \n        int m = num1.size(), n = num2.size();\n        vector<int> result(m + n, 0);\n        \n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int product = (num1[i] - '0') * (num2[j] - '0');\n                int sum = product + result[i + j + 1];\n                \n                result[i + j + 1] = sum % 10;\n                result[i + j] += sum / 10;\n            }\n        }\n        \n        string strResult;\n        for (int num : result) {\n            if (!(strResult.empty() && num == 0)) {\n                strResult += to_string(num);\n            }\n        }\n        \n        return strResult.empty() ? \"0\" : strResult;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "113_multiply_strings.cpp"
  },
  {
    "id": 114,
    "title": "Max Points on a Line",
    "description": "–ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –Ω–∞ –æ–¥–Ω–æ–π –ø—Ä—è–º–æ–π.",
    "idea": "–î–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏ —Å—á–∏—Ç–∞–µ–º —É–≥–ª–æ–≤—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã —Å –¥—Ä—É–≥–∏–º–∏ —Ç–æ—á–∫–∞–º–∏.",
    "code": "class Solution {\npublic:\n    int maxPoints(vector<vector<int>>& points) {\n        int n = points.size();\n        if (n <= 2) return n;\n        \n        int maxPoints = 1;\n        \n        for (int i = 0; i < n; i++) {\n            unordered_map<string, int> slopeCount;\n            int duplicate = 1;\n            \n            for (int j = i + 1; j < n; j++) {\n                int x1 = points[i][0], y1 = points[i][1];\n                int x2 = points[j][0], y2 = points[j][1];\n                \n                if (x1 == x2 && y1 == y2) {\n                    duplicate++;\n                    continue;\n                }\n                \n                int dx = x2 - x1, dy = y2 - y1;\n                int g = gcd(dx, dy);\n                \n                string slope = to_string(dy / g) + \"/\" + to_string(dx / g);\n                slopeCount[slope]++;\n            }\n            \n            maxPoints = max(maxPoints, duplicate);\n            for (auto& [slope, count] : slopeCount) {\n                maxPoints = max(maxPoints, count + duplicate);\n            }\n        }\n        \n        return maxPoints;\n    }\n    \n    int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "114_max_points_on_a_line.cpp"
  },
  {
    "id": 115,
    "title": "Product of Array Except Self",
    "description": "–í—ã—á–∏—Å–ª–∏—Ç—å –º–∞—Å—Å–∏–≤, –≥–¥–µ –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç - –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∫—Ä–æ–º–µ —Å–µ–±—è.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ—Ñ–∏–∫—Å–Ω—ã–µ –∏ –ø–æ—Å—Ç—Ñ–∏–∫—Å–Ω—ã–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è.",
    "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n, 1);\n        \n        // –ü—Ä–µ—Ñ–∏–∫—Å–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ\n        int prefix = 1;\n        for (int i = 0; i < n; i++) {\n            result[i] = prefix;\n            prefix *= nums[i];\n        }\n        \n        // –ü–æ—Å—Ç—Ñ–∏–∫—Å–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ\n        int postfix = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            result[i] *= postfix;\n            postfix *= nums[i];\n        }\n        \n        return result;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "115_product_of_array_except_self.cpp"
  },
  {
    "id": 116,
    "title": "Power of Three",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —á–∏—Å–ª–æ —Å—Ç–µ–ø–µ–Ω—å—é —Ç—Ä–æ–π–∫–∏.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ –∏–ª–∏ —Ü–∏–∫–ª –¥–µ–ª–µ–Ω–∏—è.",
    "code": "class Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if (n <= 0) return false;\n        \n        while (n % 3 == 0) {\n            n /= 3;\n        }\n        \n        return n == 1;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "116_power_of_three.cpp"
  },
  {
    "id": 117,
    "title": "Integer Break",
    "description": "–†–∞–∑–±–∏—Ç—å —á–∏—Å–ª–æ –Ω–∞ —Å—É–º–º—É –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª —Å –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–º –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ–º.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ - –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã —Ç—Ä–æ–π–∫–∏.",
    "code": "class Solution {\npublic:\n    int integerBreak(int n) {\n        if (n <= 3) return n - 1;\n        \n        int product = 1;\n        while (n > 4) {\n            product *= 3;\n            n -= 3;\n        }\n        \n        return product * n;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "117_integer_break.cpp"
  },
  {
    "id": 118,
    "title": "Power of Four",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —á–∏—Å–ª–æ —Å—Ç–µ–ø–µ–Ω—å—é —á–µ—Ç–≤–µ—Ä–∫–∏.",
    "idea": "–ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —á–∏—Å–ª–æ —Å—Ç–µ–ø–µ–Ω—å –¥–≤–æ–π–∫–∏ –∏ (num-1) –¥–µ–ª–∏—Ç—Å—è –Ω–∞ 3.",
    "code": "class Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        return n > 0 && (n & (n - 1)) == 0 && (n - 1) % 3 == 0;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "118_power_of_four.cpp"
  },
  {
    "id": 119,
    "title": "Add Digits",
    "description": "–°–ª–æ–∂–∏—Ç—å —Ü–∏—Ñ—Ä—ã —á–∏—Å–ª–∞ –¥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –æ–¥–Ω–æ–π —Ü–∏—Ñ—Ä—ã.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ —Ü–∏—Ñ—Ä–æ–≤–æ–≥–æ –∫–æ—Ä–Ω—è.",
    "code": "class Solution {\npublic:\n    int addDigits(int num) {\n        if (num == 0) return 0;\n        return 1 + (num - 1) % 9;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "119_add_digits.cpp"
  },
  {
    "id": 120,
    "title": "Ugly Number",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —á–∏—Å–ª–æ \"—É—Ä–æ–¥–ª–∏–≤—ã–º\" (–¥–µ–ª–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ 2, 3, 5).",
    "idea": "–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –¥–µ–ª–∏–º –Ω–∞ 2, 3, 5 –ø–æ–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ.",
    "code": "class Solution {\npublic:\n    bool isUgly(int n) {\n        if (n <= 0) return false;\n        \n        while (n % 2 == 0) n /= 2;\n        while (n % 3 == 0) n /= 3;\n        while (n % 5 == 0) n /= 5;\n        \n        return n == 1;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "120_ugly_number.cpp"
  },
  {
    "id": 121,
    "title": "Ugly Number II",
    "description": "–ù–∞–π—Ç–∏ n-–µ —É—Ä–æ–¥–ª–∏–≤–æ–µ —á–∏—Å–ª–æ.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —É—Ä–æ–¥–ª–∏–≤—ã—Ö —á–∏—Å–µ–ª.",
    "code": "class Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<int> ugly(n);\n        ugly[0] = 1;\n        \n        int i2 = 0, i3 = 0, i5 = 0;\n        \n        for (int i = 1; i < n; i++) {\n            int next2 = ugly[i2] * 2;\n            int next3 = ugly[i3] * 3;\n            int next5 = ugly[i5] * 5;\n            \n            int nextUgly = min({next2, next3, next5});\n            ugly[i] = nextUgly;\n            \n            if (nextUgly == next2) i2++;\n            if (nextUgly == next3) i3++;\n            if (nextUgly == next5) i5++;\n        }\n        \n        return ugly[n - 1];\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "121_ugly_number_ii.cpp"
  },
  {
    "id": 122,
    "title": "Super Ugly Number",
    "description": "–ù–∞–π—Ç–∏ n-–µ —Å—É–ø–µ—Ä-—É—Ä–æ–¥–ª–∏–≤–æ–µ —á–∏—Å–ª–æ (–¥–µ–ª–∏—Ç—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ –∑–∞–¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Å—Ç—ã–µ —á–∏—Å–ª–∞).",
    "idea": "–û–±–æ–±—â–µ–Ω–∏–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –Ω–∞ k —É–∫–∞–∑–∞—Ç–µ–ª–µ–π.",
    "code": "class Solution {\npublic:\n    int nthSuperUglyNumber(int n, vector<int>& primes) {\n        vector<int> ugly(n);\n        ugly[0] = 1;\n        \n        int k = primes.size();\n        vector<int> pointers(k, 0);\n        \n        for (int i = 1; i < n; i++) {\n            int minVal = INT_MAX;\n            for (int j = 0; j < k; j++) {\n                minVal = min(minVal, ugly[pointers[j]] * primes[j]);\n            }\n            ugly[i] = minVal;\n            \n            for (int j = 0; j < k; j++) {\n                if (ugly[pointers[j]] * primes[j] == minVal) {\n                    pointers[j]++;\n                }\n            }\n        }\n        \n        return ugly[n - 1];\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "122_super_ugly_number.cpp"
  },
  {
    "id": 123,
    "title": "Find K Pairs with Smallest Sums",
    "description": "–ù–∞–π—Ç–∏ k –ø–∞—Ä —Å –Ω–∞–∏–º–µ–Ω—å—à–∏–º–∏ —Å—É–º–º–∞–º–∏ –∏–∑ –¥–≤—É—Ö –º–∞—Å—Å–∏–≤–æ–≤.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –∫—É—á—É –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        vector<vector<int>> result;\n        if (nums1.empty() || nums2.empty() || k == 0) return result;\n        \n        auto cmp = [&](const pair<int, int>& a, const pair<int, int>& b) {\n            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n        };\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\n        \n        for (int i = 0; i < min(k, (int)nums1.size()); i++) {\n            pq.push({i, 0});\n        }\n        \n        while (k-- > 0 && !pq.empty()) {\n            auto [i, j] = pq.top();\n            pq.pop();\n            result.push_back({nums1[i], nums2[j]});\n            \n            if (j + 1 < nums2.size()) {\n                pq.push({i, j + 1});\n            }\n        }\n        \n        return result;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "123_find_k_pairs_with_smallest_sums.cpp"
  },
  {
    "id": 124,
    "title": "Self Crossing",
    "description": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –ª–∏ –ø—É—Ç—å —Å–∞–º —Å–µ–±—è.",
    "idea": "–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–ª—É—á–∞–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è.",
    "code": "class Solution {\npublic:\n    bool isSelfCrossing(vector<int>& x) {\n        int n = x.size();\n        if (n <= 3) return false;\n        \n        for (int i = 3; i < n; i++) {\n            // Case 1: Fourth line crosses first line\n            if (x[i] >= x[i - 2] && x[i - 1] <= x[i - 3]) return true;\n            \n            // Case 2: Fifth line meets first line\n            if (i >= 4 && x[i - 1] == x[i - 3] && x[i] + x[i - 4] >= x[i - 2]) return true;\n            \n            // Case 3: Sixth line crosses first line\n            if (i >= 5 && x[i - 2] >= x[i - 4] && \n                x[i] + x[i - 4] >= x[i - 2] && \n                x[i - 1] <= x[i - 3] && \n                x[i - 1] + x[i - 5] >= x[i - 3]) return true;\n        }\n        \n        return false;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "124_self_crossing.cpp"
  },
  {
    "id": 125,
    "title": "Paint Fence",
    "description": "–ü–æ—Å—á–∏—Ç–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–ø–æ—Å–æ–±–æ–≤ –ø–æ–∫—Ä–∞—Å–∏—Ç—å n —Å—Ç–æ–ª–±–æ–≤ k —Ü–≤–µ—Ç–∞–º–∏ –±–µ–∑ 3+ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –ø–æ–¥—Ä—è–¥.",
    "idea": "–î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –¥–≤—É–º—è —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏.",
    "code": "class Solution {\npublic:\n    int numWays(int n, int k) {\n        if (n == 0) return 0;\n        if (n == 1) return k;\n        \n        int same = k;     // –ü–æ—Å–ª–µ–¥–Ω–∏–µ –¥–≤–∞ —Å—Ç–æ–ª–±–∞ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ\n        int diff = k * (k - 1); // –ü–æ—Å–ª–µ–¥–Ω–∏–µ –¥–≤–∞ —Å—Ç–æ–ª–±–∞ —Ä–∞–∑–Ω—ã–µ\n        \n        for (int i = 3; i <= n; i++) {\n            int temp = diff;\n            diff = (same + diff) * (k - 1);\n            same = temp;\n        }\n        \n        return same + diff;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "125_paint_fence.cpp"
  },
  {
    "id": 126,
    "title": "Bulb Switcher",
    "description": "–ù–∞–π—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∫–ª—é—á–µ–Ω–Ω—ã—Ö –ª–∞–º–ø–æ—á–µ–∫ –ø–æ—Å–ª–µ n —Ä–∞—É–Ω–¥–æ–≤ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è.",
    "idea": "–õ–∞–º–ø–æ—á–∫–∞ –≤–∫–ª—é—á–µ–Ω–∞, –µ—Å–ª–∏ —É –Ω–µ–µ –Ω–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–µ–ª–∏—Ç–µ–ª–µ–π (—Ç–æ–ª—å–∫–æ –ø–æ–ª–Ω—ã–µ –∫–≤–∞–¥—Ä–∞—Ç—ã).",
    "code": "class Solution {\npublic:\n    int bulbSwitch(int n) {\n        return sqrt(n);\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "126_bulb_switcher.cpp"
  },
  {
    "id": 127,
    "title": "Nim Game",
    "description": "–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –≤—ã–∏–≥—Ä–∞—Ç—å –≤ –∏–≥—Ä–µ –ù–∏–º.",
    "idea": "–ü—Ä–æ–∏–≥—Ä—ã—à–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è - –∫–æ–≥–¥–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–º–Ω–µ–π –∫—Ä–∞—Ç–Ω–æ 4.",
    "code": "class Solution {\npublic:\n    bool canWinNim(int n) {\n        return n % 4 != 0;\n    }\n};",
    "category": "Maths (–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)",
    "difficulty": "Medium",
    "filename": "127_nim_game.cpp"
  },
  {
    "id": 128,
    "title": "Rotate Image",
    "description": "–ü–æ–≤–µ—Ä–Ω—É—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ (–º–∞—Ç—Ä–∏—Ü—É) –Ω–∞ 90 –≥—Ä–∞–¥—É—Å–æ–≤ –ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ.",
    "idea": "–¢—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä—É–µ–º –º–∞—Ç—Ä–∏—Ü—É –∏ –æ—Ç—Ä–∞–∂–∞–µ–º –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏.",
    "code": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        \n        // –¢—Ä–∞–Ω—Å–ø–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n        \n        // –û—Ç—Ä–∞–∂–µ–Ω–∏–µ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏\n        for (int i = 0; i < n; i++) {\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n    }\n};",
    "category": "Matrix",
    "difficulty": "Medium",
    "filename": "128_rotate_image.cpp"
  },
  {
    "id": 129,
    "title": "Set Matrix Zeroes",
    "description": "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω—É–ª–∏ –≤ –≤—Å–µ–π —Å—Ç—Ä–æ–∫–µ –∏ —Å—Ç–æ–ª–±—Ü–µ, –µ—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç —Ä–∞–≤–µ–Ω –Ω—É–ª—é.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É –∏ —Å—Ç–æ–ª–±–µ—Ü –∫–∞–∫ –º–∞—Ä–∫–µ—Ä—ã.",
    "code": "class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        bool firstRowZero = false, firstColZero = false;\n        \n        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É\n        for (int j = 0; j < n; j++) {\n            if (matrix[0][j] == 0) {\n                firstRowZero = true;\n                break;\n            }\n        }\n        \n        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü\n        for (int i = 0; i < m; i++) {\n            if (matrix[i][0] == 0) {\n                firstColZero = true;\n                break;\n            }\n        }\n        \n        // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∞—Ä–∫–µ—Ä—ã\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        \n        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω—É–ª–∏\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–æ–∫—É\n        if (firstRowZero) {\n            for (int j = 0; j < n; j++) matrix[0][j] = 0;\n        }\n        \n        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü\n        if (firstColZero) {\n            for (int i = 0; i < m; i++) matrix[i][0] = 0;\n        }\n    }\n};",
    "category": "Matrix",
    "difficulty": "Medium",
    "filename": "129_set_matrix_zeroes.cpp"
  },
  {
    "id": 130,
    "title": "Search a 2D Matrix",
    "description": "–ù–∞–π—Ç–∏ target –≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –º–∞—Ç—Ä–∏—Ü–µ (–∫–∞–∂–¥–∞—è —Å—Ç—Ä–æ–∫–∞ –∏ —Å—Ç–æ–ª–±–µ—Ü –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã).",
    "idea": "–ù–∞—á–∏–Ω–∞–µ–º –ø–æ–∏—Å–∫ –∏–∑ –ø—Ä–∞–≤–æ–≥–æ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É–≥–ª–∞.",
    "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if (matrix.empty() || matrix[0].empty()) return false;\n        \n        int m = matrix.size(), n = matrix[0].size();\n        int row = 0, col = n - 1;\n        \n        while (row < m && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] > target) {\n                col--;\n            } else {\n                row++;\n            }\n        }\n        return false;\n    }\n};",
    "category": "Matrix",
    "difficulty": "Medium",
    "filename": "130_search_a_2d_matrix.cpp"
  },
  {
    "id": 131,
    "title": "Search a 2D Matrix II",
    "description": "–ù–∞–π—Ç–∏ target –≤ –º–∞—Ç—Ä–∏—Ü–µ, –≥–¥–µ —Å—Ç—Ä–æ–∫–∏ –∏ —Å—Ç–æ–ª–±—Ü—ã –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –ø–æ –æ—Ç–¥–µ–ª—å–Ω–æ—Å—Ç–∏.",
    "idea": "–ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –∑–∞–¥–∞—á–µ, –Ω–∞—á–∏–Ω–∞–µ–º –∏–∑ –ø—Ä–∞–≤–æ–≥–æ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É–≥–ª–∞.",
    "code": "class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if (matrix.empty() || matrix[0].empty()) return false;\n        \n        int m = matrix.size(), n = matrix[0].size();\n        int row = 0, col = n - 1;\n        \n        while (row < m && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] > target) {\n                col--;\n            } else {\n                row++;\n            }\n        }\n        return false;\n    }\n};",
    "category": "Matrix",
    "difficulty": "Medium",
    "filename": "131_search_a_2d_matrix_ii.cpp"
  },
  {
    "id": 132,
    "title": "Spiral Matrix",
    "description": "–í–µ—Ä–Ω—É—Ç—å —ç–ª–µ–º–µ–Ω—Ç—ã –º–∞—Ç—Ä–∏—Ü—ã –≤ —Å–ø–∏—Ä–∞–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.",
    "idea": "–û–±—Ö–æ–¥–∏–º –º–∞—Ç—Ä–∏—Ü—É –ø–æ —Å–ª–æ—è–º —Å —á–µ—Ç—ã—Ä—å–º—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏.",
    "code": "class Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        if (matrix.empty()) return {};\n        \n        int m = matrix.size(), n = matrix[0].size();\n        vector<int> result;\n        \n        int top = 0, bottom = m - 1, left = 0, right = n - 1;\n        \n        while (top <= bottom && left <= right) {\n            // –í–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–æ–∫–∞\n            for (int j = left; j <= right; j++) {\n                result.push_back(matrix[top][j]);\n            }\n            top++;\n            \n            // –ü—Ä–∞–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü\n            for (int i = top; i <= bottom; i++) {\n                result.push_back(matrix[i][right]);\n            }\n            right--;\n            \n            if (top <= bottom) {\n                // –ù–∏–∂–Ω—è—è —Å—Ç—Ä–æ–∫–∞\n                for (int j = right; j >= left; j--) {\n                    result.push_back(matrix[bottom][j]);\n                }\n                bottom--;\n            }\n            \n            if (left <= right) {\n                // –õ–µ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü\n                for (int i = bottom; i >= top; i--) {\n                    result.push_back(matrix[i][left]);\n                }\n                left++;\n            }\n        }\n        \n        return result;\n    }\n};",
    "category": "Matrix",
    "difficulty": "Medium",
    "filename": "132_spiral_matrix.cpp"
  },
  {
    "id": 133,
    "title": "Spiral Matrix II",
    "description": "–ó–∞–ø–æ–ª–Ω–∏—Ç—å –º–∞—Ç—Ä–∏—Ü—É —á–∏—Å–ª–∞–º–∏ –æ—Ç 1 –¥–æ n¬≤ –≤ —Å–ø–∏—Ä–∞–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.",
    "idea": "–ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –∑–∞–¥–∞—á–µ, –Ω–æ –∑–∞–ø–æ–ª–Ω—è–µ–º —á–∏—Å–ª–∞–º–∏.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> matrix(n, vector<int>(n));\n        \n        int top = 0, bottom = n - 1, left = 0, right = n - 1;\n        int num = 1;\n        \n        while (top <= bottom && left <= right) {\n            // –í–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–æ–∫–∞\n            for (int j = left; j <= right; j++) {\n                matrix[top][j] = num++;\n            }\n            top++;\n            \n            // –ü—Ä–∞–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü\n            for (int i = top; i <= bottom; i++) {\n                matrix[i][right] = num++;\n            }\n            right--;\n            \n            if (top <= bottom) {\n                // –ù–∏–∂–Ω—è—è —Å—Ç—Ä–æ–∫–∞\n                for (int j = right; j >= left; j--) {\n                    matrix[bottom][j] = num++;\n                }\n                bottom--;\n            }\n            \n            if (left <= right) {\n                // –õ–µ–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü\n                for (int i = bottom; i >= top; i--) {\n                    matrix[i][left] = num++;\n                }\n                left++;\n            }\n        }\n        \n        return matrix;\n    }\n};",
    "category": "Matrix",
    "difficulty": "Medium",
    "filename": "133_spiral_matrix_ii.cpp"
  },
  {
    "id": 134,
    "title": "LRU Cache",
    "description": "–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∫—ç—à —Å –ø–æ–ª–∏—Ç–∏–∫–æ–π –≤—ã—Ç–µ—Å–Ω–µ–Ω–∏—è Least Recently Used.",
    "idea": "–ò—Å–ø–æ–ª—å–∑—É–µ–º —Ö—ç—à-—Ç–∞–±–ª–∏—Ü—É –∏ –¥–≤—É—Å–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è.",
    "code": "class LRUCache {\nprivate:\n    struct Node {\n        int key;\n        int value;\n        Node* prev;\n        Node* next;\n        Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\n    };\n    \n    int capacity;\n    unordered_map<int, Node*> cache;\n    Node* head;\n    Node* tail;\n    \n    void addToHead(Node* node) {\n        node->next = head->next;\n        node->prev = head;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(Node* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n    \n    void moveToHead(Node* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n    \n    Node* removeTail() {\n        Node* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n    \npublic:\n    LRUCache(int capacity) : capacity(capacity) {\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) return -1;\n        \n        Node* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (cache.count(key)) {\n            Node* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        } else {\n            Node* newNode = new Node(key, value);\n            cache[key] = newNode;\n            addToHead(newNode);\n            \n            if (cache.size() > capacity) {\n                Node* tailNode = removeTail();\n                cache.erase(tailNode->key);\n                delete tailNode;\n            }\n        }\n    }\n};",
    "category": "Design",
    "difficulty": "Hard",
    "filename": "134_lru_cache.cpp"
  }
];
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        document.addEventListener('DOMContentLoaded', function() {
            // –†–µ–Ω–¥–µ—Ä–∏–º —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á
            renderProblemList();
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–≤—É—é –∑–∞–¥–∞—á—É
            if (problems.length > 0) {
                loadProblem(problems[0]);
                document.querySelector('.problem-item').classList.add('active');
            }
            
            // –ü–æ–∏—Å–∫
            document.getElementById('search').addEventListener('input', function(e) {
                const term = e.target.value.toLowerCase();
                document.querySelectorAll('.problem-item').forEach(item => {
                    const text = item.textContent.toLowerCase();
                    item.style.display = text.includes(term) ? 'flex' : 'none';
                });
            });
            
            // –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
            document.getElementById('copy-code').addEventListener('click', function() {
                const code = document.getElementById('code').textContent;
                navigator.clipboard.writeText(code).then(() => {
                    const original = this.textContent;
                    this.textContent = '‚úì –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
                    setTimeout(() => this.textContent = original, 2000);
                });
            });
        });
        
        // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Å–ø–∏—Å–∫–∞ –∑–∞–¥–∞—á
        function renderProblemList() {
            const container = document.getElementById('problem-list');
            container.innerHTML = '';
            
            problems.forEach(problem => {
                const div = document.createElement('div');
                div.className = 'problem-item';
                div.style.display = 'flex';
                div.style.alignItems = 'center';
                div.innerHTML = `
                    <div style="flex: 0 0 40px;">
                        <span class="problem-id">${problem.id.toString().padStart(3, '0')}</span>
                    </div>
                    <div style="flex: 1;">
                        <div class="problem-title">${problem.title}</div>
                        <div class="problem-meta">
                            ${problem.category}
                            <span class="difficulty ${problem.difficulty.toLowerCase()}">${problem.difficulty}</span>
                        </div>
                    </div>
                `;
                
                div.addEventListener('click', () => {
                    document.querySelectorAll('.problem-item').forEach(i => i.classList.remove('active'));
                    div.classList.add('active');
                    loadProblem(problem);
                });
                
                container.appendChild(div);
            });
        }
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–¥–∞—á–∏
        function loadProblem(problem) {
            // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
            document.getElementById('problem-title').textContent = problem.title;
            document.getElementById('problem-id').textContent = `#${problem.id.toString().padStart(3, '0')}`;
            document.getElementById('problem-category').textContent = problem.category;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ª–æ–∂–Ω–æ—Å—Ç—å
            const diffElement = document.getElementById('problem-difficulty');
            diffElement.textContent = problem.difficulty;
            diffElement.className = 'difficulty ' + problem.difficulty.toLowerCase();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ –∏ –∏–¥–µ—é
            document.getElementById('problem-description').textContent = problem.description;
            document.getElementById('problem-idea').textContent = problem.idea;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–¥
            const codeElement = document.getElementById('code');
            codeElement.textContent = problem.code;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∏–º—è —Ñ–∞–π–ª–∞
            document.getElementById('file-name').textContent = problem.filename;
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
            hljs.highlightElement(codeElement);
            
            // –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –∫ –Ω–∞—á–∞–ª—É
            document.querySelector('.main-content').scrollTop = 0;
        }
    </script>
</body>
</html>